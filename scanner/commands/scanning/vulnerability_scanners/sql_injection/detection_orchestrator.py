"""
ReconScan SQL Injection Detection Orchestrator

Coordinates multiple SQL injection detection techniques and manages the overall
scanning process with intelligent technique selection and result validation.
"""

import asyncio
import aiohttp
from typing import Dict, List, Optional, Tuple, Any, Callable
from dataclasses import dataclass
from enum import Enum
import time
import statistics

from .response_analyzer import (
    SQLInjectionResponseAnalyzer, 
    DetectionTechnique, 
    DetectionResult,
    DatabaseType
)
from .sql_payload_crafting_engine import (
    PayloadCraftingEngine,
    PayloadCraftingContext,
    InjectionTechnique,
    DatabaseType as CraftingDatabaseType
)
from ..shared.injection_discovery import InjectionPoint, ParameterType

class ScanMode(Enum):
    """SQL injection scanning modes."""
    FAST = "fast"           # Quick detection with basic payloads
    THOROUGH = "thorough"   # Comprehensive scanning with multiple techniques
    STEALTH = "stealth"     # Slow, careful scanning to avoid detection
    AGGRESSIVE = "aggressive" # Fast, comprehensive scanning

@dataclass
class ScanConfiguration:
    """Configuration for SQL injection scanning."""
    mode: ScanMode
    max_payloads_per_technique: int
    timeout: float
    delay_between_requests: float
    validation_enabled: bool
    validation_payloads_count: int
    confidence_threshold: float
    max_concurrent_requests: int
    enable_baseline_comparison: bool
    enable_database_fingerprinting: bool

@dataclass
class ScanProgress:
    """Progress tracking for SQL injection scan."""
    total_injection_points: int
    completed_injection_points: int
    current_technique: str
    vulnerabilities_found: int
    total_requests_sent: int
    scan_start_time: float
    estimated_time_remaining: float

@dataclass
class VulnerabilityFinding:
    """Comprehensive vulnerability finding result."""
    injection_point: InjectionPoint
    detection_result: DetectionResult
    validation_results: List[DetectionResult]
    database_type: Optional[DatabaseType]
    exploitation_potential: str
    risk_level: str
    recommended_payloads: List[str]
    scan_metadata: Dict[str, Any]

class SQLInjectionDetectionOrchestrator:
    """Orchestrates SQL injection detection across multiple techniques."""
    
    def __init__(self, session: aiohttp.ClientSession):
        """Initialize the detection orchestrator."""
        self.session = session
        self.response_analyzer = SQLInjectionResponseAnalyzer()
        self.payload_engine = PayloadCraftingEngine()
        
        # Scan state
        self.scan_results = {}
        self.baseline_responses = {}
        self.scan_statistics = {
            'total_requests': 0,
            'vulnerabilities_found': 0,
            'techniques_used': set(),
            'scan_duration': 0.0
        }
        
        # Predefined scan configurations
        self.scan_configs = {
            ScanMode.FAST: ScanConfiguration(
                mode=ScanMode.FAST,
                max_payloads_per_technique=3,
                timeout=5.0,
                delay_between_requests=0.1,
                validation_enabled=False,
                validation_payloads_count=2,
                confidence_threshold=0.6,
                max_concurrent_requests=5,
                enable_baseline_comparison=True,
                enable_database_fingerprinting=False
            ),
            ScanMode.THOROUGH: ScanConfiguration(
                mode=ScanMode.THOROUGH,
                max_payloads_per_technique=8,
                timeout=10.0,
                delay_between_requests=0.3,
                validation_enabled=True,
                validation_payloads_count=5,
                confidence_threshold=0.4,
                max_concurrent_requests=3,
                enable_baseline_comparison=True,
                enable_database_fingerprinting=True
            ),
            ScanMode.STEALTH: ScanConfiguration(
                mode=ScanMode.STEALTH,
                max_payloads_per_technique=5,
                timeout=15.0,
                delay_between_requests=2.0,
                validation_enabled=True,
                validation_payloads_count=3,
                confidence_threshold=0.7,
                max_concurrent_requests=1,
                enable_baseline_comparison=True,
                enable_database_fingerprinting=True
            ),
            ScanMode.AGGRESSIVE: ScanConfiguration(
                mode=ScanMode.AGGRESSIVE,
                max_payloads_per_technique=12,
                timeout=8.0,
                delay_between_requests=0.05,
                validation_enabled=True,
                validation_payloads_count=4,
                confidence_threshold=0.3,
                max_concurrent_requests=10,
                enable_baseline_comparison=True,
                enable_database_fingerprinting=True
            )
        }
    
    async def scan_injection_points(self, 
                                  injection_points: List[InjectionPoint],
                                  scan_mode: ScanMode = ScanMode.THOROUGH,
                                  custom_config: Optional[ScanConfiguration] = None,
                                  progress_callback: Optional[Callable] = None) -> List[VulnerabilityFinding]:
        """Scan multiple injection points for SQL injection vulnerabilities."""
        
        config = custom_config or self.scan_configs[scan_mode]
        findings = []
        scan_start = time.time()
        
        # Initialize progress tracking
        progress = ScanProgress(
            total_injection_points=len(injection_points),
            completed_injection_points=0,
            current_technique="Initializing",
            vulnerabilities_found=0,
            total_requests_sent=0,
            scan_start_time=scan_start,
            estimated_time_remaining=0.0
        )
        
        try:
            # Establish baselines if enabled
            if config.enable_baseline_comparison:
                await self._establish_baselines(injection_points, config)
            
            # Process injection points
            semaphore = asyncio.Semaphore(config.max_concurrent_requests)
            
            tasks = []
            for injection_point in injection_points:
                task = asyncio.create_task(
                    self._scan_single_injection_point(injection_point, config, semaphore)
                )
                tasks.append(task)
            
            # Process results as they complete
            for i, task in enumerate(asyncio.as_completed(tasks)):
                finding = await task
                if finding:
                    findings.append(finding)
                    progress.vulnerabilities_found += 1
                
                progress.completed_injection_points = i + 1
                progress.estimated_time_remaining = self._estimate_remaining_time(
                    progress, scan_start
                )
                
                if progress_callback:
                    progress_callback(progress)
        
        except Exception as e:
            print(f"Scan error: {e}")
        
        finally:
            # Update scan statistics
            self.scan_statistics['scan_duration'] = time.time() - scan_start
            self.scan_statistics['vulnerabilities_found'] = len(findings)
        
        return findings
    
    async def _scan_single_injection_point(self, 
                                         injection_point: InjectionPoint,
                                         config: ScanConfiguration,
                                         semaphore: asyncio.Semaphore) -> Optional[VulnerabilityFinding]:
        """Scan a single injection point for vulnerabilities."""
        
        async with semaphore:
            try:
                # Create payload crafting context
                context = PayloadCraftingContext(
                    parameter_name=injection_point.parameter,
                    parameter_value=injection_point.original_value,
                    parameter_type=self._map_parameter_type(injection_point.parameter_type),
                    url=injection_point.url,
                    method=injection_point.method
                )
                
                # Test each detection technique
                techniques_to_test = self._select_techniques(injection_point, config)
                
                best_result = None
                all_results = []
                
                for technique in techniques_to_test:
                    result = await self._test_technique(
                        injection_point, technique, context, config
                    )
                    
                    if result and result.vulnerable:
                        all_results.append(result)
                        if not best_result or result.confidence > best_result.confidence:
                            best_result = result
                
                # If vulnerability found, validate and create finding
                if best_result and best_result.confidence >= config.confidence_threshold:
                    
                    validation_results = []
                    if config.validation_enabled:
                        validation_results = await self._validate_vulnerability(
                            injection_point, best_result, context, config
                        )
                    
                    # Determine database type
                    database_type = await self._fingerprint_database(
                        injection_point, context, config
                    ) if config.enable_database_fingerprinting else None
                    
                    # Create comprehensive finding
                    finding = VulnerabilityFinding(
                        injection_point=injection_point,
                        detection_result=best_result,
                        validation_results=validation_results,
                        database_type=database_type,
                        exploitation_potential=self._assess_exploitation_potential(best_result),
                        risk_level=self._calculate_risk_level(best_result, injection_point),
                        recommended_payloads=self._get_recommended_payloads(
                            injection_point, best_result, database_type
                        ),
                        scan_metadata={
                            'scan_mode': config.mode.value,
                            'techniques_tested': [t.value for t in techniques_to_test],
                            'total_results': len(all_results),
                            'validation_count': len(validation_results)
                        }
                    )
                    
                    return finding
                    
            except Exception as e:
                print(f"Error scanning {injection_point.parameter}: {e}")
                return None
            
            finally:
                # Add delay between requests
                await asyncio.sleep(config.delay_between_requests)
        
        return None
    
    async def _test_technique(self, 
                            injection_point: InjectionPoint,
                            technique: DetectionTechnique,
                            context: PayloadCraftingContext,
                            config: ScanConfiguration) -> Optional[DetectionResult]:
        """Test a specific detection technique."""
        
        try:
            # Map technique to crafting technique
            crafting_technique = self._map_to_crafting_technique(technique)
            
            # Generate payloads for this technique
            payloads = self.payload_engine.craft_payloads(
                context, 
                count=config.max_payloads_per_technique,
                techniques=[crafting_technique]
            )
            
            if not payloads:
                return None
            
            best_result = None
            
            # Test each payload
            for payload_data in payloads[:config.max_payloads_per_technique]:
                payload = payload_data['payload']
                
                # Send request with payload
                response_data = await self._send_payload_request(
                    injection_point, payload, config
                )
                
                if not response_data:
                    continue
                
                # Analyze response
                baseline_key = self._get_baseline_key(injection_point)
                result = self.response_analyzer.analyze_response(
                    response_data['content'],
                    response_data['timing'],
                    response_data['headers'],
                    response_data['status_code'],
                    payload,
                    technique,
                    baseline_key
                )
                
                # Track the best result
                if result.vulnerable and (not best_result or result.confidence > best_result.confidence):
                    best_result = result
                
                # Update statistics
                self.scan_statistics['total_requests'] += 1
                self.scan_statistics['techniques_used'].add(technique.value)
            
            return best_result
            
        except Exception as e:
            print(f"Error testing technique {technique.value}: {e}")
            return None
    
    async def _send_payload_request(self, 
                                  injection_point: InjectionPoint,
                                  payload: str,
                                  config: ScanConfiguration) -> Optional[Dict[str, Any]]:
        """Send HTTP request with SQL injection payload."""
        
        try:
            # Construct request based on injection point
            if injection_point.method.upper() == 'GET':
                # URL parameter injection
                url = f"{injection_point.url}?{injection_point.parameter}={payload}"
                start_time = time.time()
                
                async with self.session.get(url, timeout=aiohttp.ClientTimeout(total=config.timeout)) as response:
                    content = await response.text()
                    timing = time.time() - start_time
                    
                    return {
                        'content': content,
                        'timing': timing,
                        'headers': dict(response.headers),
                        'status_code': response.status
                    }
            
            elif injection_point.method.upper() == 'POST':
                # POST data injection
                data = {injection_point.parameter: payload}
                start_time = time.time()
                
                async with self.session.post(injection_point.url, data=data, 
                                           timeout=aiohttp.ClientTimeout(total=config.timeout)) as response:
                    content = await response.text()
                    timing = time.time() - start_time
                    
                    return {
                        'content': content,
                        'timing': timing,
                        'headers': dict(response.headers),
                        'status_code': response.status
                    }
            
        except asyncio.TimeoutError:
            # Timeout might indicate time-based injection
            return {
                'content': '',
                'timing': config.timeout,
                'headers': {},
                'status_code': 408
            }
        
        except Exception as e:
            print(f"Request error: {e}")
            return None
    
    async def _establish_baselines(self, 
                                 injection_points: List[InjectionPoint],
                                 config: ScanConfiguration) -> None:
        """Establish baseline responses for comparison."""
        
        for injection_point in injection_points:
            try:
                # Send normal request
                response_data = await self._send_payload_request(
                    injection_point, injection_point.original_value, config
                )
                
                if response_data:
                    baseline_key = self._get_baseline_key(injection_point)
                    self.response_analyzer.establish_baseline(
                        response_data['content'],
                        response_data['timing'],
                        response_data['headers'],
                        response_data['status_code']
                    )
                    
                    self.baseline_responses[baseline_key] = response_data
                    
            except Exception as e:
                print(f"Error establishing baseline for {injection_point.parameter}: {e}")
    
    async def _validate_vulnerability(self, 
                                    injection_point: InjectionPoint,
                                    initial_result: DetectionResult,
                                    context: PayloadCraftingContext,
                                    config: ScanConfiguration) -> List[DetectionResult]:
        """Validate vulnerability with additional payloads."""
        
        validation_results = []
        
        try:
            # Generate validation payloads
            crafting_technique = self._map_to_crafting_technique(initial_result.technique)
            validation_payloads = self.payload_engine.craft_payloads(
                context,
                count=config.validation_payloads_count,
                techniques=[crafting_technique]
            )
            
            # Test validation payloads
            for payload_data in validation_payloads:
                payload = payload_data['payload']
                
                response_data = await self._send_payload_request(
                    injection_point, payload, config
                )
                
                if response_data:
                    baseline_key = self._get_baseline_key(injection_point)
                    result = self.response_analyzer.analyze_response(
                        response_data['content'],
                        response_data['timing'],
                        response_data['headers'],
                        response_data['status_code'],
                        payload,
                        initial_result.technique,
                        baseline_key
                    )
                    
                    validation_results.append(result)
        
        except Exception as e:
            print(f"Error validating vulnerability: {e}")
        
        return validation_results
    
    async def _fingerprint_database(self, 
                                  injection_point: InjectionPoint,
                                  context: PayloadCraftingContext,
                                  config: ScanConfiguration) -> Optional[DatabaseType]:
        """Fingerprint the database type using error-based techniques."""
        
        try:
            # Generate database-specific error payloads
            error_payloads = self.payload_engine.craft_payloads(
                context,
                count=5,
                techniques=[InjectionTechnique.ERROR]
            )
            
            responses = []
            for payload_data in error_payloads:
                payload = payload_data['payload']
                
                response_data = await self._send_payload_request(
                    injection_point, payload, config
                )
                
                if response_data:
                    responses.append(response_data['content'])
            
            if responses:
                return self.response_analyzer.fingerprint_database(responses)
                
        except Exception as e:
            print(f"Error fingerprinting database: {e}")
        
        return None
    
    def _select_techniques(self, 
                          injection_point: InjectionPoint,
                          config: ScanConfiguration) -> List[DetectionTechnique]:
        """Select appropriate detection techniques based on context."""
        
        techniques = []
        
        # Always include error-based detection (fastest)
        techniques.append(DetectionTechnique.ERROR_BASED)
        
        # Add boolean-based for most parameter types
        if injection_point.parameter_type in [ParameterType.NUMERIC, ParameterType.STRING]:
            techniques.append(DetectionTechnique.BOOLEAN_BLIND)
        
        # Add time-based for thorough scanning
        if config.mode in [ScanMode.THOROUGH, ScanMode.AGGRESSIVE]:
            techniques.append(DetectionTechnique.TIME_BASED)
        
        # Add UNION-based for GET parameters
        if injection_point.method.upper() == 'GET':
            techniques.append(DetectionTechnique.UNION_BASED)
        
        # Add stacked queries for aggressive scanning
        if config.mode == ScanMode.AGGRESSIVE:
            techniques.append(DetectionTechnique.STACKED_QUERIES)
        
        return techniques
    
    def _map_to_crafting_technique(self, detection_technique: DetectionTechnique) -> InjectionTechnique:
        """Map detection technique to payload crafting technique."""
        mapping = {
            DetectionTechnique.ERROR_BASED: InjectionTechnique.ERROR,
            DetectionTechnique.BOOLEAN_BLIND: InjectionTechnique.BOOLEAN,
            DetectionTechnique.TIME_BASED: InjectionTechnique.TIME,
            DetectionTechnique.UNION_BASED: InjectionTechnique.UNION,
            DetectionTechnique.STACKED_QUERIES: InjectionTechnique.STACKED
        }
        return mapping.get(detection_technique, InjectionTechnique.BOOLEAN)
    
    def _map_parameter_type(self, param_type: ParameterType) -> str:
        """Map injection point parameter type to crafting context type."""
        mapping = {
            ParameterType.NUMERIC: 'numeric',
            ParameterType.STRING: 'string',
            ParameterType.JSON: 'json',
            ParameterType.UNKNOWN: 'string'
        }
        return mapping.get(param_type, 'string')
    
    def _get_baseline_key(self, injection_point: InjectionPoint) -> str:
        """Generate baseline key for injection point."""
        return f"{injection_point.url}:{injection_point.parameter}"
    
    def _assess_exploitation_potential(self, result: DetectionResult) -> str:
        """Assess exploitation potential based on detection result."""
        if result.technique == DetectionTechnique.UNION_BASED:
            return "High - Direct data extraction possible"
        elif result.technique == DetectionTechnique.ERROR_BASED:
            return "High - Error-based data extraction possible"
        elif result.technique == DetectionTechnique.BOOLEAN_BLIND:
            return "Medium - Blind data extraction possible"
        elif result.technique == DetectionTechnique.TIME_BASED:
            return "Medium - Time-based blind extraction possible"
        elif result.technique == DetectionTechnique.STACKED_QUERIES:
            return "Critical - Full database control possible"
        else:
            return "Unknown"
    
    def _calculate_risk_level(self, result: DetectionResult, injection_point: InjectionPoint) -> str:
        """Calculate risk level based on multiple factors."""
        base_risk = 0
        
        # Technique-based risk
        technique_risk = {
            DetectionTechnique.STACKED_QUERIES: 10,
            DetectionTechnique.UNION_BASED: 9,
            DetectionTechnique.ERROR_BASED: 8,
            DetectionTechnique.BOOLEAN_BLIND: 7,
            DetectionTechnique.TIME_BASED: 6
        }
        base_risk += technique_risk.get(result.technique, 5)
        
        # Confidence-based risk
        base_risk += int(result.confidence * 5)
        
        # Parameter type risk
        if injection_point.parameter_type == ParameterType.NUMERIC:
            base_risk += 2
        
        # Method-based risk
        if injection_point.method.upper() == 'POST':
            base_risk += 1
        
        # Categorize risk
        if base_risk >= 15:
            return "Critical"
        elif base_risk >= 12:
            return "High"
        elif base_risk >= 8:
            return "Medium"
        else:
            return "Low"
    
    def _get_recommended_payloads(self, 
                                injection_point: InjectionPoint,
                                result: DetectionResult,
                                database_type: Optional[DatabaseType]) -> List[str]:
        """Get recommended payloads for exploitation."""
        
        context = PayloadCraftingContext(
            parameter_name=injection_point.parameter,
            parameter_value=injection_point.original_value,
            parameter_type=self._map_parameter_type(injection_point.parameter_type),
            url=injection_point.url,
            method=injection_point.method
        )
        
        # Map database type if available
        target_db = None
        if database_type:
            db_mapping = {
                DatabaseType.MYSQL: CraftingDatabaseType.MYSQL,
                DatabaseType.POSTGRESQL: CraftingDatabaseType.POSTGRESQL,
                DatabaseType.MSSQL: CraftingDatabaseType.MSSQL,
                DatabaseType.ORACLE: CraftingDatabaseType.ORACLE,
                DatabaseType.SQLITE: CraftingDatabaseType.SQLITE
            }
            target_db = db_mapping.get(database_type)
        
        # Generate exploitation payloads
        crafting_technique = self._map_to_crafting_technique(result.technique)
        payloads = self.payload_engine.craft_payloads(
            context,
            count=5,
            techniques=[crafting_technique],
            target_databases=[target_db] if target_db else None
        )
        
        return [p['payload'] for p in payloads[:5]]
    
    def _estimate_remaining_time(self, progress: ScanProgress, start_time: float) -> float:
        """Estimate remaining scan time."""
        if progress.completed_injection_points == 0:
            return 0.0
        
        elapsed = time.time() - start_time
        avg_time_per_point = elapsed / progress.completed_injection_points
        remaining_points = progress.total_injection_points - progress.completed_injection_points
        
        return avg_time_per_point * remaining_points
    
    def get_scan_statistics(self) -> Dict[str, Any]:
        """Get comprehensive scan statistics."""
        return {
            **self.scan_statistics,
            'techniques_used': list(self.scan_statistics['techniques_used']),
            'requests_per_second': (
                self.scan_statistics['total_requests'] / self.scan_statistics['scan_duration']
                if self.scan_statistics['scan_duration'] > 0 else 0
            )
        } 