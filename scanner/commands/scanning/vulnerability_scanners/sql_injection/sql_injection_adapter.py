"""
ReconScan SQL Injection Scanner Adapter

Adapter that integrates the advanced SQL injection scanner with the standard
ReconScan scanning workflow. Provides a consistent interface while leveraging
the sophisticated SQL injection detection capabilities.
"""

import asyncio
import aiohttp
from typing import List, Dict, Any, Optional
from urllib.parse import urljoin, urlparse, parse_qs
import time

# Color definitions for consistent CLI output
BLUE = '\033[94m'
GREEN = '\033[1;38;5;28m'  # Bold forest green
YELLOW = '\033[93m'
RED = '\033[91m'
CYAN = '\033[96m'
ENDC = '\033[0m'  # End color

from .sql_injection_scanner import SQLInjectionScanner, ScanMode, VulnerabilityFinding
from ...shared.injection_discovery import (
    InjectionPoint, 
    InjectionPointType, 
    ParameterType,
    InjectionPointDiscovery
)


class SQLInjectionScannerAdapter:
    """
    Adapter for integrating the advanced SQL injection scanner with ReconScan's
    standard scanning workflow.
    """
    
    def __init__(self, ai_validator=None):
        """Initialize the SQL injection scanner adapter."""
        self.ai_validator = ai_validator
        self.injection_discovery = InjectionPointDiscovery()
        self.scanner = None  # Will be initialized with session
        
    async def scan(self, session: aiohttp.ClientSession, target: str, discovered_urls=None, verbose=True):
        """
        Scan target for SQL injection vulnerabilities using the standard interface.
        
        Args:
            session: aiohttp session for HTTP requests
            target: Target URL to scan
            discovered_urls: Previously discovered URLs (optional)
            verbose: Enable verbose output
            
        Returns:
            List of vulnerability dictionaries in standard format
        """
        vulnerabilities = []
        
        try:
            # Initialize the advanced scanner with session
            self.scanner = SQLInjectionScanner(session, self.ai_validator)
            
            if verbose:
                print(f"{BLUE}[*]{ENDC} Starting SQL Injection Analysis on {target}")
            
            # Discover injection points
            urls_to_test = discovered_urls if discovered_urls else [target]
            injection_points = await self._discover_injection_points(session, urls_to_test, verbose)
            
            if not injection_points:
                if verbose:
                    print(f"  {YELLOW}[!]{ENDC} No testable parameters found")
                return vulnerabilities
            
            if verbose:
                print(f"  {GREEN}[+]{ENDC} Found {len(injection_points)} injection points to test")
            
            # Run SQL injection scan
            findings = await self.scanner.scan_injection_points(
                injection_points=injection_points,
                scan_mode=ScanMode.THOROUGH,
                progress_callback=self._progress_callback if verbose else None
            )
            
            # Convert findings to standard vulnerability format
            for finding in findings:
                vuln = self._convert_finding_to_vulnerability(finding)
                vulnerabilities.append(vuln)
                
                if verbose:
                    print(f"  {GREEN}[+]{ENDC} SQL Injection detected: {vuln['type']} ({vuln['severity']})")
            
            return vulnerabilities
            
        except Exception as e:
            if verbose:
                print(f"  {RED}[-]{ENDC} SQL injection scan error: {e}")
            return vulnerabilities
    
    async def _discover_injection_points(self, session: aiohttp.ClientSession, 
                                       urls: List[str], verbose: bool) -> List[InjectionPoint]:
        """Discover potential SQL injection points from URLs."""
        injection_points = []
        
        for url in urls:
            try:
                # Test GET parameters
                parsed = urlparse(url)
                if parsed.query:
                    params = parse_qs(parsed.query)
                    for param, values in params.items():
                        if values:  # Skip empty parameters
                            injection_point = InjectionPoint(
                                name=f"{param} (GET)",
                                value=values[0],
                                injection_type=InjectionPointType.QUERY_PARAMETER,
                                parameter_type=self._detect_parameter_type(values[0]),
                                url=url,
                                method='GET',
                                location='query'
                            )
                            injection_points.append(injection_point)
                
                # Test POST parameters (basic form discovery)
                try:
                    async with session.get(url) as response:
                        if response.status == 200:
                            content = await response.text()
                            # Simple form parsing
                            forms = await self._extract_form_parameters(content, url)
                            for form_param in forms:
                                injection_points.append(form_param)
                                
                except Exception:
                    pass  # Skip if unable to fetch page
                    
            except Exception as e:
                if verbose:
                    print(f"   ⚠️  Error processing {url}: {e}")
        
        return injection_points
    
    async def _extract_form_parameters(self, html_content: str, base_url: str) -> List[InjectionPoint]:
        """Extract form parameters from HTML content."""
        injection_points = []
        
        # Basic form parameter extraction (simplified)
        import re
        
        # Find input fields in forms
        input_pattern = r'<input[^>]*name=["\']([^"\']+)["\'][^>]*>'
        matches = re.findall(input_pattern, html_content, re.IGNORECASE)
        
        for match in matches:
            param_name = match
            if param_name.lower() not in ['submit', 'button', 'reset']:  # Skip non-data inputs
                injection_point = InjectionPoint(
                    name=f"{param_name} (POST)",
                    value="test",
                    injection_type=InjectionPointType.POST_PARAMETER,
                    parameter_type=ParameterType.STRING,
                    url=base_url,
                    method='POST',
                    location='form'
                )
                injection_points.append(injection_point)
        
        return injection_points
    
    def _detect_parameter_type(self, value: str) -> ParameterType:
        """Detect parameter type from value."""
        try:
            int(value)
            return ParameterType.NUMERIC
        except ValueError:
            pass
        
        # Check for JSON-like structure
        if value.startswith('{') and value.endswith('}'):
            return ParameterType.JSON_OBJECT
        
        return ParameterType.STRING
    
    def _convert_finding_to_vulnerability(self, finding: VulnerabilityFinding) -> Dict[str, Any]:
        """Convert VulnerabilityFinding to standard vulnerability dictionary."""
        
        # Map technique to vulnerability type
        technique_map = {
            'error_based': 'SQL Injection (Error-based)',
            'boolean_blind': 'SQL Injection (Boolean-based blind)',
            'time_based': 'SQL Injection (Time-based blind)',
            'union_based': 'SQL Injection (UNION query)',
            'stacked_queries': 'SQL Injection (Stacked queries)'
        }
        
        # Map confidence to severity
        if finding.confidence >= 0.8:
            severity = 'Critical'
        elif finding.confidence >= 0.6:
            severity = 'High'
        elif finding.confidence >= 0.4:
            severity = 'Medium'
        else:
            severity = 'Low'
        
        vulnerability = {
            'type': technique_map.get(finding.technique.value, f'SQL Injection ({finding.technique.value})'),
            'severity': severity,
            'confidence': finding.confidence,
            'url': finding.injection_point.url,
            'method': finding.injection_point.method,
            'parameter': finding.injection_point.name,
            'payload': finding.payload_used,
            'evidence': finding.evidence,
            'description': self._generate_description(finding),
            'impact': finding.exploitation_potential,
            'recommendation': self._generate_recommendation(finding),
            'database_type': finding.database_type.value if finding.database_type else 'Unknown',
            'validation_passed': finding.validation_passed,
            'scan_metadata': finding.scan_metadata
        }
        
        return vulnerability
    
    def _generate_description(self, finding: VulnerabilityFinding) -> str:
        """Generate detailed description for the vulnerability."""
        base_desc = (
            f"SQL injection vulnerability detected in parameter '{finding.injection_point.name}' "
            f"using {finding.technique.value.replace('_', ' ')} technique. "
        )
        
        if finding.database_type and finding.database_type.value != 'unknown':
            base_desc += f"Database type identified as {finding.database_type.value.upper()}. "
        
        if finding.validation_passed:
            base_desc += "Vulnerability confirmed through validation testing. "
        
        return base_desc + "This vulnerability allows attackers to manipulate SQL queries and potentially access or modify database contents."
    
    def _generate_recommendation(self, finding: VulnerabilityFinding) -> str:
        """Generate remediation recommendation."""
        recommendations = [
            "Use parameterized queries or prepared statements",
            "Implement proper input validation and sanitization",
            "Apply the principle of least privilege for database accounts",
            "Enable database query logging and monitoring",
            "Consider using an ORM framework with built-in SQL injection protection"
        ]
        
        if finding.technique.value == 'error_based':
            recommendations.insert(1, "Implement proper error handling to prevent information disclosure")
        elif finding.technique.value == 'time_based':
            recommendations.insert(1, "Implement query timeout mechanisms")
        
        return "; ".join(recommendations)
    
    def _progress_callback(self, completed: int, total: int, vulnerabilities_found: int):
        """Progress callback for verbose output."""
        percentage = (completed / total) * 100
        print(f"  {CYAN}[*]{ENDC} Progress: {completed}/{total} ({percentage:.1f}%) - {vulnerabilities_found} vulnerabilities found") 