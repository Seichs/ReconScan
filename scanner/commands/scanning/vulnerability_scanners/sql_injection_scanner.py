"""
ReconScan SQL Injection Scanner

Dedicated module for SQL injection vulnerability detection with advanced payload generation.
Supports error-based, boolean-based, and time-based detection methods with WAF evasion.
"""

import asyncio
import aiohttp
import urllib.parse
import time
from urllib.parse import urlparse, urlencode, urlunparse, parse_qs
from ..payloads.sql_injection_payloads import SQLInjectionPayloads
from ..enhanced_payload_manager import EnhancedPayloadManager, VulnerabilityType, PayloadContext

class SQLInjectionScanner:
    """
    Advanced SQL injection vulnerability scanner with enhanced payload generation.
    
    Implements multiple detection techniques including error-based analysis,
    boolean-based blind injection, and time-based blind injection detection.
    Enhanced with context-aware payloads and WAF evasion capabilities.
    """
    
    def __init__(self, false_positive_filters=None, system_config=None):
        """
        Initialize SQL injection scanner with enhanced capabilities.
        
        Args:
            false_positive_filters: FalsePositiveFilters instance
            system_config: System configuration instance
        """
        self.false_positive_filters = false_positive_filters
        self.system_config = system_config
        
        # Initialize payload library and enhanced manager
        self.payload_library = SQLInjectionPayloads()
        self.enhanced_manager = EnhancedPayloadManager()
        
        # Get payloads from library (using medium severity by default)
        self.payloads = self.payload_library.get_targeted_payloads('medium')
        
        # TODO: Implement advanced response analysis for better vulnerability detection
        # TODO: Add support for second-order SQL injection detection
        
        # SQL error indicators for error-based detection
        self.error_indicators = [
            'mysql_fetch_array', 'ORA-01756', 'Microsoft OLE DB',
            'SQLServer JDBC Driver', 'PostgreSQL query failed',
            'sqlite_master', 'SQL syntax', 'mysql_num_rows',
            'Warning: mysql', 'Warning: mysqli', 'MySQL Error',
            'ORA-00', 'Microsoft VBScript runtime', 'ADODB.Field',
            'mysql_connect', 'mysql_query', 'mysql_result',
            'PostgreSQL query failed', 'supplied argument is not a valid MySQL',
            'Column count doesn\'t match', 'mysql_fetch_assoc',
            'mysql_fetch_row', 'mysql_fetch_object', 'mysql_numrows',
            'Error Occurred While Processing Request', 'Server Error',
            'Microsoft OLE DB Provider for ODBC Drivers',
            'Invalid Querystring', 'OLE DB Provider for SQL Server',
            'Unclosed quotation mark after the character string',
            'Microsoft OLE DB Provider for Oracle', 'error in your SQL syntax',
            'Syntax error in query expression', 'Data source name not found',
            'Incorrect syntax near', 'mysql_error', 'mysql_errno',
            'Warning: pg_', 'valid PostgreSQL result', 'Npgsql\\.',
            'PG::SyntaxError', 'org.postgresql.util.PSQLException',
            'ERROR: parser: parse error', 'PostgreSQL.*ERROR',
            'Warning.*\\Wpg_', 'valid PostgreSQL result', 'Npgsql\\.',
            'Exception (Npgsql|PG|PostgreSQL)', 'Microsoft Access Driver',
            'JET Database Engine', 'Access Database Engine'
        ]
        
        # Time-based detection configuration
        self.time_delay_threshold = self._get_time_delay_threshold()
    
    def _get_time_delay_threshold(self):
        """Get time delay threshold from configuration."""
        if self.system_config:
            sql_config = self.system_config.get_payload_defaults('sql_injection')
            return sql_config.get('time_based_delay', 5)
        return 5  # Default 5 seconds
    
    def _determine_parameter_type(self, param_value):
        """Determine the type of parameter for context-aware payload generation."""
        if isinstance(param_value, list) and param_value:
            param_value = param_value[0]
        
        if str(param_value).isdigit():
            return 'numeric'
        elif '{' in str(param_value) and '}' in str(param_value):
            return 'json'
        else:
            return 'string'
    
    async def _get_baseline_response(self, session, url):
        """Get baseline response for comparison in boolean-based detection."""
        try:
            async with session.get(url) as response:
                content = await response.text()
                return content, response.status
        except Exception:
            return "", 0
    
    async def scan(self, session, target, discovered_urls=None, verbose=True):
        """
        Perform enhanced SQL injection vulnerability scan with adaptive payloads.
        
        Args:
            session: aiohttp session for HTTP requests
            target (str): Target URL to scan
            discovered_urls (list, optional): Pre-discovered URLs with parameters
            verbose (bool): Enable verbose output
            
        Returns:
            list: List of discovered SQL injection vulnerabilities
        """
        if verbose:
            print("  \033[1;38;5;28m→\033[0m Testing SQL injection with enhanced payloads...")
        
        vulnerabilities = []
        vulnerabilities_found = 0
        urls_to_test = []
        
        # Use discovered URLs if available, otherwise use common parameters
        if discovered_urls:
            urls_to_test = discovered_urls
        else:
            # Fallback to common parameter names
            parameters = ['id', 'user', 'username', 'page', 'cat', 'category', 'artist', 'search', 'q', 'query', 'name', 'login']
            for param in parameters:
                urls_to_test.append(f"{target}?{param}=1")
        
        # Get baseline response for technology detection
        baseline_content, _ = await self._get_baseline_response(session, target)
        
        for base_url in urls_to_test:
            # Parse URL to extract parameters
            parsed_url = urlparse(base_url)
            params_dict = parse_qs(parsed_url.query)
            
            # Test each parameter in the URL
            for param_name, param_values in params_dict.items():
                # Create context for enhanced payload generation
                context = PayloadContext(
                    parameter_name=param_name,
                    parameter_type=self._determine_parameter_type(param_values),
                    injection_point=f"{param_name}={param_values[0] if param_values else ''}",
                    response_content=baseline_content
                )
                
                # Generate adaptive payloads using enhanced manager
                adaptive_payloads = self.enhanced_manager.generate_adaptive_payloads(
                    VulnerabilityType.SQL_INJECTION,
                    context,
                    max_payloads=25  # Comprehensive adaptive payload set
                )
                
                # Use ALL traditional payloads for maximum coverage
                # Don't limit - each payload tests different attack vectors
                all_traditional_payloads = self.payloads  # Use all available traditional payloads
                
                # Combine adaptive + traditional + context-specific payloads
                all_payloads = adaptive_payloads + all_traditional_payloads
                
                # Add database-specific payloads if technology detected
                if context.detected_technology.get('database'):
                    db_type = context.detected_technology['database']
                    if db_type == 'mysql':
                        all_payloads.extend(self.payload_library.mysql_payloads)
                    elif db_type == 'postgresql':
                        all_payloads.extend(self.payload_library.postgresql_payloads)
                    elif db_type == 'mssql':
                        all_payloads.extend(self.payload_library.mssql_payloads)
                    elif db_type == 'oracle':
                        all_payloads.extend(self.payload_library.oracle_payloads)
                
                # Add framework-specific payloads if framework detected
                if context.detected_technology.get('framework'):
                    framework = context.detected_technology['framework']
                    framework_payloads = self.enhanced_manager.get_technology_specific_payloads(
                        VulnerabilityType.SQL_INJECTION, framework
                    )
                    all_payloads.extend(framework_payloads)
                
                # Remove duplicates while preserving order (but don't limit count)
                seen = set()
                unique_payloads = []
                for payload in all_payloads:
                    if payload not in seen:
                        seen.add(payload)
                        unique_payloads.append(payload)
                
                all_payloads = unique_payloads
                
                if verbose and len(all_payloads) > 30:
                    print(f"     \033[1;91m→\033[0m Using {len(all_payloads)} comprehensive SQL injection payloads for {param_name}")
                
                for payload in all_payloads:
                    try:
                        # Create test URL with payload
                        test_params = params_dict.copy()
                        test_params[param_name] = [payload]
                        test_query = urlencode(test_params, doseq=True)
                        test_url = urlunparse((parsed_url.scheme, parsed_url.netloc, parsed_url.path, 
                                             parsed_url.params, test_query, parsed_url.fragment))
                        
                        # Measure response time for time-based detection
                        start_time = time.time()
                        
                        async with session.get(test_url) as response:
                            content = await response.text()
                            status_code = response.status
                            response_time = time.time() - start_time
                            
                            # Update context with response for WAF detection
                            context.response_content = content
                            
                            # Track payload success for adaptive learning
                            payload_successful = False
                            
                            # Check for SQL errors (error-based detection)
                            if any(indicator.lower() in content.lower() for indicator in self.error_indicators):
                                # Check if this is a known false positive (if filtering is enabled)
                                if self._is_false_positive_filtering_enabled() and self.false_positive_filters:
                                    fp_result = self.false_positive_filters.is_sql_injection_false_positive(test_url, param_name, payload)
                                    if fp_result:
                                        if verbose:
                                            print(f"     SQL injection pattern filtered ({fp_result['ai_label']}): {param_name}={payload}")
                                            print(f"       Reason: {fp_result['reason']}")
                                        continue
                                
                                vulnerability = {
                                    'type': 'SQL Injection (Error-based)',
                                    'severity': 'High',
                                    'url': test_url,
                                    'payload': payload,
                                    'parameter': param_name,
                                    'method': 'Enhanced Context-Aware Detection',
                                    'description': f'SQL injection vulnerability detected in parameter "{param_name}" through enhanced error-based testing',
                                    'evidence': [indicator for indicator in self.error_indicators if indicator.lower() in content.lower()][:3]
                                }
                                vulnerabilities.append(vulnerability)
                                vulnerabilities_found += 1
                                payload_successful = True
                                
                                if verbose:
                                    print(f"     \033[1;91mX\033[0m Enhanced SQL injection found: {param_name}={payload}")
                                break
                            
                            # Check for time-based blind SQL injection
                            elif payload in self.payload_library.get_time_based_payloads() or 'SLEEP' in payload.upper() or 'WAITFOR' in payload.upper():
                                if response_time >= self.time_delay_threshold:
                                    # Verify with second request to reduce false positives
                                    verification_start = time.time()
                                    async with session.get(test_url) as verify_response:
                                        await verify_response.text()
                                        verification_time = time.time() - verification_start
                                    
                                    # If both requests show delay, likely vulnerable
                                    if verification_time >= self.time_delay_threshold:
                                        # Check if this is a known false positive
                                        if self._is_false_positive_filtering_enabled() and self.false_positive_filters:
                                            fp_result = self.false_positive_filters.is_sql_injection_false_positive(test_url, param_name, payload)
                                            if fp_result:
                                                if verbose:
                                                    print(f"     Time-based SQL injection pattern filtered ({fp_result['ai_label']}): {param_name}={payload}")
                                                    print(f"       Reason: {fp_result['reason']}")
                                                continue
                                        
                                        vulnerability = {
                                            'type': 'SQL Injection (Time-based Blind)',
                                            'severity': 'High',
                                            'url': test_url,
                                            'payload': payload,
                                            'parameter': param_name,
                                            'method': 'Enhanced Time-based Detection',
                                            'description': f'Time-based blind SQL injection detected in parameter "{param_name}" using enhanced payloads (response delay: {response_time:.2f}s)',
                                            'response_time': response_time
                                        }
                                        vulnerabilities.append(vulnerability)
                                        vulnerabilities_found += 1
                                        payload_successful = True
                                        
                                        if verbose:
                                            print(f"     \033[1;91mX\033[0m Enhanced time-based SQL injection found: {param_name}={payload} (delay: {response_time:.2f}s)")
                                        break
                            
                            # Check for boolean-based blind SQL injection (basic detection)
                            elif payload in self.payload_library.get_boolean_based_payloads()[:5]:
                                # Simple boolean-based detection using response length differences
                                if len(content) > 0:  # Basic check for response
                                    # Test with a payload that should return false
                                    false_payload = payload.replace("'1'='1", "'1'='2").replace('"1"="1', '"1"="2')
                                    if false_payload != payload:
                                        false_params = params_dict.copy()
                                        false_params[param_name] = [false_payload]
                                        false_query = urlencode(false_params, doseq=True)
                                        false_url = urlunparse((parsed_url.scheme, parsed_url.netloc, parsed_url.path, 
                                                               parsed_url.params, false_query, parsed_url.fragment))
                                        
                                        try:
                                            async with session.get(false_url) as false_response:
                                                false_content = await false_response.text()
                                                
                                                # If responses are significantly different, might be vulnerable
                                                if abs(len(content) - len(false_content)) > 100:
                                                    # Check if this is a known false positive
                                                    if self._is_false_positive_filtering_enabled() and self.false_positive_filters:
                                                        fp_result = self.false_positive_filters.is_sql_injection_false_positive(test_url, param_name, payload)
                                                        if fp_result:
                                                            if verbose:
                                                                print(f"     Boolean SQL injection pattern filtered ({fp_result['ai_label']}): {param_name}={payload}")
                                                                print(f"       Reason: {fp_result['reason']}")
                                                            continue
                                                    
                                                    vulnerability = {
                                                        'type': 'SQL Injection (Boolean-based Blind)',
                                                        'severity': 'High',
                                                        'url': test_url,
                                                        'payload': payload,
                                                        'parameter': param_name,
                                                        'method': 'Enhanced Boolean-based Detection',
                                                        'description': f'Boolean-based blind SQL injection detected in parameter "{param_name}" (response length difference: {abs(len(content) - len(false_content))} chars)',
                                                        'response_length_diff': abs(len(content) - len(false_content))
                                                    }
                                                    vulnerabilities.append(vulnerability)
                                                    vulnerabilities_found += 1
                                                    payload_successful = True
                                                    
                                                    if verbose:
                                                        print(f"     \033[1;91mX\033[0m Enhanced boolean-based SQL injection found: {param_name}={payload}")
                                                    break
                                        except Exception:
                                            pass  # Skip boolean test if it fails
                            
                            # Update adaptive learning with payload success
                            self.enhanced_manager.update_payload_success(
                                VulnerabilityType.SQL_INJECTION,
                                payload,
                                payload_successful
                            )
                            
                    except asyncio.TimeoutError:
                        # Timeout might indicate time-based injection
                        if verbose:
                            print(f"     \033[1;93m!\033[0m Timeout detected for payload: {payload[:50]}...")
                        # Consider timeout as potential time-based injection
                        if payload in self.payload_library.get_time_based_payloads():
                            vulnerability = {
                                'type': 'SQL Injection (Time-based Blind - Timeout)',
                                'severity': 'Medium',
                                'url': test_url,
                                'payload': payload,
                                'parameter': param_name,
                                'method': 'Enhanced Timeout Detection',
                                'description': f'Potential time-based blind SQL injection detected through timeout in parameter "{param_name}"'
                            }
                            vulnerabilities.append(vulnerability)
                            vulnerabilities_found += 1
                    except Exception as e:
                        if verbose:
                            print(f"    \033[1;91mWarning\033[0m: Error testing payload {payload[:30]}...: {str(e)}")
                        continue
        
        if verbose:
            print(f"  \033[1;38;5;28m→\033[0m Enhanced SQL injection scan completed. Found {vulnerabilities_found} vulnerabilities.")
        
        return vulnerabilities
    
    def _is_false_positive_filtering_enabled(self):
        """Check if false positive filtering is enabled in configuration."""
        if not self.system_config:
            return True  # Default to enabled
        
        sql_config = self.system_config.get_payload_defaults('sql_injection')
        return sql_config.get('false_positive_filtering', True) 