"""
ReconScan SQL Injection Scanner

Dedicated module for SQL injection vulnerability detection.
Supports error-based, boolean-based, and time-based detection methods.
"""

import asyncio
import aiohttp
import urllib.parse
import time
from urllib.parse import urlparse, urlencode, urlunparse, parse_qs
from ..payloads.sql_injection_payloads import SQLInjectionPayloads

class SQLInjectionScanner:
    """
    Advanced SQL injection vulnerability scanner.
    
    Implements multiple detection techniques including error-based analysis,
    boolean-based blind injection, and time-based blind injection detection.
    """
    
    def __init__(self, false_positive_filters=None, system_config=None):
        """
        Initialize SQL injection scanner.
        
        Args:
            false_positive_filters: FalsePositiveFilters instance
            system_config: System configuration instance
        """
        self.false_positive_filters = false_positive_filters
        self.system_config = system_config
        
        # Initialize payload library
        self.payload_library = SQLInjectionPayloads()
        
        # Get payloads from library (using medium severity by default)
        self.payloads = self.payload_library.get_targeted_payloads('medium')
        
        # SQL error indicators for error-based detection
        self.error_indicators = [
            'mysql_fetch_array', 'ORA-01756', 'Microsoft OLE DB',
            'SQLServer JDBC Driver', 'PostgreSQL query failed',
            'sqlite_master', 'SQL syntax', 'mysql_num_rows',
            'Warning: mysql', 'Warning: mysqli', 'MySQL Error',
            'ORA-00', 'Microsoft VBScript runtime', 'ADODB.Field',
            'mysql_connect', 'mysql_query', 'mysql_result',
            'PostgreSQL query failed', 'supplied argument is not a valid MySQL',
            'Column count doesn\'t match', 'mysql_fetch_assoc',
            'mysql_fetch_row', 'mysql_fetch_object', 'mysql_numrows',
            'Error Occurred While Processing Request', 'Server Error',
            'Microsoft OLE DB Provider for ODBC Drivers',
            'Invalid Querystring', 'OLE DB Provider for SQL Server',
            'Unclosed quotation mark after the character string',
            'Microsoft OLE DB Provider for Oracle', 'error in your SQL syntax',
            'Syntax error in query expression', 'Data source name not found',
            'Incorrect syntax near', 'mysql_error', 'mysql_errno',
            'Warning: pg_', 'valid PostgreSQL result', 'Npgsql\\.',
            'PG::SyntaxError', 'org.postgresql.util.PSQLException',
            'ERROR: parser: parse error', 'PostgreSQL.*ERROR',
            'Warning.*\\Wpg_', 'valid PostgreSQL result', 'Npgsql\\.',
            'Exception (Npgsql|PG|PostgreSQL)', 'Microsoft Access Driver',
            'JET Database Engine', 'Access Database Engine'
        ]
        
        # Time-based detection configuration
        self.time_delay_threshold = self._get_time_delay_threshold()
    
    def _get_time_delay_threshold(self):
        """Get time delay threshold from configuration."""
        if self.system_config:
            sql_config = self.system_config.get_payload_defaults('sql_injection')
            return sql_config.get('time_based_delay', 5)
        return 5  # Default 5 seconds
    
    async def scan(self, session, target, discovered_urls=None, verbose=True):
        """
        Perform SQL injection vulnerability scan.
        
        Args:
            session: aiohttp session for HTTP requests
            target (str): Target URL to scan
            discovered_urls (list, optional): Pre-discovered URLs with parameters
            verbose (bool): Enable verbose output
            
        Returns:
            list: List of discovered SQL injection vulnerabilities
        """
        if verbose:
            print("  â†’ Testing SQL injection payloads...")
        
        vulnerabilities = []
        vulnerabilities_found = 0
        urls_to_test = []
        
        # Use discovered URLs if available, otherwise use common parameters
        if discovered_urls:
            urls_to_test = discovered_urls
        else:
            # Fallback to common parameter names
            parameters = ['id', 'user', 'username', 'page', 'cat', 'category', 'artist', 'search', 'q', 'query', 'name', 'login']
            for param in parameters:
                urls_to_test.append(f"{target}?{param}=1")
        
        for base_url in urls_to_test:
            # Parse URL to extract parameters
            parsed_url = urlparse(base_url)
            params_dict = parse_qs(parsed_url.query)
            
            # Test each parameter in the URL
            for param_name, param_values in params_dict.items():
                for payload in self.payloads:
                    try:
                        # Create test URL with payload
                        test_params = params_dict.copy()
                        test_params[param_name] = [payload]
                        test_query = urlencode(test_params, doseq=True)
                        test_url = urlunparse((parsed_url.scheme, parsed_url.netloc, parsed_url.path, 
                                             parsed_url.params, test_query, parsed_url.fragment))
                        
                        # Measure response time for time-based detection
                        start_time = time.time()
                        
                        async with session.get(test_url) as response:
                            content = await response.text()
                            status_code = response.status
                            response_time = time.time() - start_time
                            
                            # Check for SQL errors (error-based detection)
                            if any(indicator.lower() in content.lower() for indicator in self.error_indicators):
                                # Check if this is a known false positive (if filtering is enabled)
                                if self._is_false_positive_filtering_enabled() and self.false_positive_filters:
                                    fp_result = self.false_positive_filters.is_sql_injection_false_positive(test_url, param_name, payload)
                                    if fp_result:
                                        if verbose:
                                            print(f"     SQL injection pattern filtered ({fp_result['ai_label']}): {param_name}={payload}")
                                            print(f"       Reason: {fp_result['reason']}")
                                        continue
                                
                                vulnerability = {
                                    'type': 'SQL Injection (Error-based)',
                                    'severity': 'High',
                                    'url': test_url,
                                    'payload': payload,
                                    'description': f'SQL injection vulnerability detected in parameter "{param_name}" through error-based testing'
                                }
                                vulnerabilities.append(vulnerability)
                                vulnerabilities_found += 1
                                if verbose:
                                    print(f"     SQL injection found: {param_name}={payload}")
                                break
                            
                            # Check for time-based blind SQL injection
                            elif payload in self.payload_library.get_time_based_payloads():
                                if response_time >= self.time_delay_threshold:
                                    # Verify with second request to reduce false positives
                                    verification_start = time.time()
                                    async with session.get(test_url) as verify_response:
                                        await verify_response.text()
                                        verification_time = time.time() - verification_start
                                    
                                    # If both requests show delay, likely vulnerable
                                    if verification_time >= self.time_delay_threshold:
                                        # Check if this is a known false positive
                                        if self._is_false_positive_filtering_enabled() and self.false_positive_filters:
                                            fp_result = self.false_positive_filters.is_sql_injection_false_positive(test_url, param_name, payload)
                                            if fp_result:
                                                if verbose:
                                                    print(f"     Time-based SQL injection pattern filtered ({fp_result['ai_label']}): {param_name}={payload}")
                                                    print(f"       Reason: {fp_result['reason']}")
                                                continue
                                        
                                        vulnerability = {
                                            'type': 'SQL Injection (Time-based Blind)',
                                            'severity': 'High',
                                            'url': test_url,
                                            'payload': payload,
                                            'description': f'Time-based blind SQL injection detected in parameter "{param_name}" (response delay: {response_time:.2f}s)'
                                        }
                                        vulnerabilities.append(vulnerability)
                                        vulnerabilities_found += 1
                                        if verbose:
                                            print(f"     Time-based SQL injection found: {param_name}={payload} (delay: {response_time:.2f}s)")
                                        break
                            
                            # Check for boolean-based blind SQL injection
                            elif payload in self.payload_library.get_boolean_based_payloads()[:3]:
                                # Get baseline response with original parameter value
                                baseline_params = params_dict.copy()
                                baseline_query = urlencode(baseline_params, doseq=True)
                                baseline_url = urlunparse((parsed_url.scheme, parsed_url.netloc, parsed_url.path,
                                                         parsed_url.params, baseline_query, parsed_url.fragment))
                                
                                async with session.get(baseline_url) as baseline_response:
                                    baseline_content = await baseline_response.text()
                                    
                                    # If response is significantly different, might be vulnerable
                                    if len(content) != len(baseline_content) and abs(len(content) - len(baseline_content)) > 100:
                                        # Check if this is a known false positive (if filtering is enabled)
                                        if self._is_false_positive_filtering_enabled() and self.false_positive_filters:
                                            fp_result = self.false_positive_filters.is_sql_injection_false_positive(test_url, param_name, payload)
                                            if fp_result:
                                                if verbose:
                                                    print(f"     Boolean SQL injection pattern filtered ({fp_result['ai_label']}): {param_name}={payload}")
                                                    print(f"       Reason: {fp_result['reason']}")
                                                break
                                        
                                        vulnerability = {
                                            'type': 'SQL Injection (Boolean-based Blind)',
                                            'severity': 'High',
                                            'url': test_url,
                                            'payload': payload,
                                            'description': f'Potential boolean-based blind SQL injection in parameter "{param_name}"'
                                        }
                                        vulnerabilities.append(vulnerability)
                                        vulnerabilities_found += 1
                                        if verbose:
                                            print(f"     Boolean SQL injection found: {param_name}={payload}")
                                        break
                            
                    except Exception as e:
                        if verbose:
                            print(f"    ! Error testing {param_name} with '{payload}': {str(e)}")
                        continue
        
        if verbose and vulnerabilities_found == 0:
            print("     No SQL injection vulnerabilities detected")
        
        return vulnerabilities
    
    def _is_false_positive_filtering_enabled(self):
        """Check if false positive filtering is enabled in configuration."""
        if not self.system_config:
            return True  # Default to enabled
        
        sql_config = self.system_config.get_payload_defaults('sql_injection')
        return sql_config.get('false_positive_filtering', True) 