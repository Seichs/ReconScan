"""
ReconScan LFI Scanner

Local File Inclusion vulnerability detection module.
"""

import asyncio
import aiohttp
import urllib.parse
from .lfi_payloads import LFIPayloads
from scanner.ai import AIVulnerabilityValidator

class LFIScanner:
    """Local File Inclusion vulnerability scanner."""
    
    def __init__(self, ai_validator=None):
        """Initialize LFI scanner with AI validation."""
        # Initialize payload library
        self.payload_library = LFIPayloads()
        
        # Get payloads from library (using medium severity by default)
        self.payloads = self.payload_library.get_targeted_payloads('medium')
        
        # Get success indicators from library
        self.lfi_indicators = self.payload_library.get_success_indicators()
        
        # Initialize AI validator
        self.ai_validator = ai_validator or AIVulnerabilityValidator()
    
    async def scan(self, session, target, config=None, verbose=True):
        """Perform LFI vulnerability scan with multiple parameter testing."""
        if verbose:
            print("  \033[1;38;5;28m→\033[0m Testing LFI payloads...")
        
        vulnerabilities = []
        vulnerabilities_found = 0
        consecutive_errors = 0
        max_consecutive_errors = 5
        
        # Common parameter names for LFI testing
        common_params = ['file', 'path', 'page', 'include', 'inc', 'load', 'doc', 'document', 'template', 'view']
        
        for param in common_params:
            for payload in self.payloads[:10]:  # Test first 10 payloads per parameter
                try:
                    test_url = f"{target}?{param}={urllib.parse.quote(payload)}"
                    
                    timeout = 10
                    if config:
                        timeout = config.get('network', {}).get('timeout', 10)
                    
                    async with session.get(test_url, timeout=aiohttp.ClientTimeout(total=timeout)) as response:
                        content = await response.text()
                        consecutive_errors = 0
                        
                        if any(indicator in content for indicator in self.lfi_indicators):
                            # Use AI validation for LFI assessment
                            ai_result = self.ai_validator.validate_file_inclusion(
                                test_url, param, payload, content, 
                                dict(response.headers), response.status, 0.0, 'lfi'
                            )
                            
                            # If AI determines it's not vulnerable, skip
                            if ai_result.get('is_vulnerable') is False:
                                if verbose:
                                    print(f"    \033[1;94mAI\033[0m LFI filtered (confidence: {ai_result.get('confidence', 0):.2f}): {param}={payload}")
                                    print(f"      Reason: {ai_result.get('reason', 'AI analysis')}")
                                continue
                            
                            vulnerability = {
                                'type': 'Local File Inclusion (LFI)',
                                'severity': 'High',
                                'url': test_url,
                                'payload': payload,
                                'description': f'LFI vulnerability detected in parameter "{param}" through file content disclosure',
                                'ai_confidence': ai_result.get('confidence', 0.0),
                                'ai_confidence_level': ai_result.get('confidence_level', 'unknown'),
                                'ai_recommendation': ai_result.get('recommendation', 'Manual verification recommended')
                            }
                            vulnerabilities.append(vulnerability)
                            vulnerabilities_found += 1
                            if verbose:
                                print(f"    \033[1;91mX\033[0m LFI vulnerability found: {param}={payload} (AI confidence: {ai_result.get('confidence', 0):.2f})")
                            break
                            
                except asyncio.TimeoutError:
                    consecutive_errors += 1
                    if verbose and consecutive_errors <= max_consecutive_errors:
                        print(f"    ! Timeout testing LFI payload (error {consecutive_errors})")
                    if consecutive_errors >= max_consecutive_errors:
                        if verbose:
                            print("    ! Too many consecutive timeouts, stopping LFI scan...")
                        break
                except Exception as e:
                    consecutive_errors += 1
                    if verbose and consecutive_errors <= max_consecutive_errors:
                        print(f"    \033[1;91mWarning\033[0m: Error testing {param} with '{payload[:30]}...': {str(e)}")
                    if consecutive_errors >= max_consecutive_errors:
                        if verbose:
                            print("    ! Too many consecutive errors, stopping LFI scan...")
                        break
                        
                # Add small delay between requests to avoid overwhelming target
                if config:
                    delay = config.get('scanning', {}).get('delay', 0.5)
                    await asyncio.sleep(delay)
            
            # If found vulnerability in this parameter, skip to next parameter
            if vulnerabilities_found > 0:
                break
            
            # Break if too many consecutive errors
            if consecutive_errors >= max_consecutive_errors:
                break
        
        if verbose and vulnerabilities_found == 0:
            print("    ✓ No LFI vulnerabilities detected")
        
        return vulnerabilities 